-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators and useful tools for ANNs using the backprop library
--   
--   See README.md
@package backprop-learn
@version 0.1.0.0

module Numeric.Tensor
class SingKind k => Tensor (t :: k -> Type) where type IndexT t :: k -> Type type ElemT t :: Type where {
    type family IndexT t :: k -> Type;
    type family ElemT t :: Type;
}
genA :: (Tensor t, Applicative f) => Sing s -> (IndexT t s -> f (ElemT t)) -> f (t s)
gen :: Tensor t => Sing s -> (IndexT t s -> ElemT t) -> t s
tkonst :: Tensor t => Sing s -> ElemT t -> t s
tsum :: (Tensor t, SingI s) => t s -> ElemT t
tmap :: (Tensor t, SingI s) => (ElemT t -> ElemT t) -> t s -> t s
tzip :: (Tensor t, SingI s) => (ElemT t -> ElemT t -> ElemT t) -> t s -> t s -> t s

module Numeric.BLAS
class BLAS (b :: BShape Nat -> Type) where type Scalar b :: Type where {
    type family Scalar b :: Type;
}
scal :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BV n)
axpy :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BV n) -> b (BV n)
dot :: (BLAS b, KnownNat n) => b (BV n) -> b (BV n) -> Scalar b
norm2 :: (BLAS b, KnownNat n) => b (BV n) -> Scalar b
asum :: (BLAS b, KnownNat n) => b (BV n) -> Scalar b
iamax :: (BLAS b, KnownNat n) => b (BV n) -> Finite n
gemv :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BM m n) -> b (BV n) -> Scalar b -> b (BV m) -> b (BV m)
ger :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BV m) -> b (BV n) -> b (BM m n) -> b (BM m n)
syr :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BM n n) -> b (BM n n)
gemm :: (BLAS b, KnownNat m, KnownNat o, KnownNat n) => Scalar b -> b (BM m o) -> b (BM o n) -> Scalar b -> b (BM m n) -> b (BM m n)
syrk :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BM m n) -> Scalar b -> b (BM m m) -> b (BM m m)
data BShape a_anhz
BV :: !a_anhz -> BShape a_anhz
BM :: !a_anhz -> !a_anhz -> BShape a_anhz

-- | The singleton kind-indexed data family.
type SBShape = (Sing :: BShape a_anhz -> Type)
data BIndex :: BShape Nat -> Type
[BVIx] :: Finite n -> BIndex (BV n)
[BMIx] :: Finite m -> Finite n -> BIndex (BM m n)
instance GHC.Base.Functor Numeric.BLAS.BShape
instance GHC.Classes.Ord a0 => GHC.Classes.Ord (Numeric.BLAS.BShape a0)
instance GHC.Classes.Eq a0 => GHC.Classes.Eq (Numeric.BLAS.BShape a0)
instance GHC.Show.Show a0 => GHC.Show.Show (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Eq.PEq 'Data.Proxy.Proxy
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BVSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BMSym1
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BMSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.Compare_6989586621679106245Sym1
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.Compare_6989586621679106245Sym0
instance Data.Singletons.Prelude.Ord.POrd 'Data.Proxy.Proxy
instance Data.Singletons.SingKind a0 => Data.Singletons.SingKind (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Eq.SEq a0 => Data.Singletons.Prelude.Eq.SEq (Numeric.BLAS.BShape a0)
instance Data.Singletons.Decide.SDecide a0 => Data.Singletons.Decide.SDecide (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Ord.SOrd a0 => Data.Singletons.Prelude.Ord.SOrd (Numeric.BLAS.BShape a0)
instance forall a0 (n0 :: a0). Data.Singletons.SingI n0 => Data.Singletons.SingI ('Numeric.BLAS.BV n0)
instance forall a0 (n0 :: a0) (n1 :: a0). (Data.Singletons.SingI n0, Data.Singletons.SingI n1) => Data.Singletons.SingI ('Numeric.BLAS.BM n0 n1)

module Numeric.BLAS.HMatrix
newtype HM :: BShape Nat -> Type
[HM] :: {getHM :: HM' b} -> HM b
instance Numeric.BLAS.BLAS Numeric.BLAS.HMatrix.HM
instance Numeric.Tensor.Tensor Numeric.BLAS.HMatrix.HM
instance Data.Singletons.SingI s => Data.MonoTraversable.MonoFunctor (Numeric.BLAS.HMatrix.HM s)
instance Data.Singletons.SingI s => Data.MonoTraversable.MonoFoldable (Numeric.BLAS.HMatrix.HM s)

module Learn.Neural
class Component c where type CParam c (b :: BShape Nat -> Type) (i :: BShape Nat) (o :: BShape Nat) = (p :: Type) | p -> c type CState c (b :: BShape Nat -> Type) (i :: BShape Nat) (o :: BShape Nat) = (s :: Maybe Type) | s -> c where {
    type family CParam c
                       (b :: BShape Nat -> Type)
                       (i :: BShape Nat)
                       (o :: BShape Nat) = (p :: Type) | p -> c;
    type family CState c
                       (b :: BShape Nat -> Type)
                       (i :: BShape Nat)
                       (o :: BShape Nat) = (s :: Maybe Type) | s -> c;
}
runComponent :: forall s b i o. Component c => OpB s (b i : (CParam c b i o : MaybeToList (CState c b i o))) (b o : MaybeToList (CState c b i o))
initComponent :: (Component c, ContGen d) => Sing i -> Sing o -> d -> Gen (PrimState m) -> m (Tuple (CParam c b i o : MaybeToList (CState c b i o)))
data HasState
NoState :: HasState
SomeState :: HasState
data Layer :: Type -> HasState -> (BShape Nat -> Type) -> BShape Nat -> BShape Nat -> Type
[LPure] :: (CState c b i o ~ Nothing) => CParam c b i o -> Layer c r b i o
[LState] :: (CState c b i o ~ Just s) => CParam c b i o -> s -> Layer c SomeState b i o
layerOp :: forall s c r b i o. Component c => OpB s '[b i, Layer c r b i o] '[b o, Layer c r b i o]
layerOpPure :: forall s c b i o. Component c => OpB s '[b i, Layer c NoState b i o] '[b o]
data LChain :: Type
[:~] :: BShape Nat -> Type -> LChain
data Network :: HasState -> (BShape Nat -> Type) -> LChain -> [LChain] -> BShape Nat -> Type
[NetExt] :: Layer c r b i o -> Network r b (i :~ c) '[] o
[:&] :: Component d => Layer c r b i h -> Network r b (h :~ d) hs o -> Network r b (i :~ c) ((h :~ d) : hs) o
networkOp :: forall s r b i c hs o. Component c => OpB s '[b i, Network r b (i :~ c) hs o] '[b o, Network r b (i :~ c) hs o]
networkOpPure :: forall s b i c hs o. Component c => OpB s '[b i, Network NoState b (i :~ c) hs o] '[b o]
instance GHC.Num.Num (Learn.Neural.Layer c r b i o)
