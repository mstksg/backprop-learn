-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators and useful tools for ANNs using the backprop library
--   
--   See README.md
@package backprop-learn
@version 0.1.0.0

module Backprop.Learn

module Data.Type.Mayb
data Mayb :: (k -> Type) -> Maybe k -> Type
[N_] :: Mayb f  'Nothing
[J_] :: f a -> Mayb f ( 'Just a)
fromJ_ :: Mayb f ( 'Just a) -> f a
maybToList :: Mayb f m -> Prod f (MaybeToList m)
listToMayb :: Prod f as -> Mayb f (ListToMaybe as)
data P :: k -> Type
[P] :: P a
type KnownMayb = Known (Mayb P)
knownMayb :: KnownMayb p => Mayb P p
zipMayb :: (forall a. f a -> g a -> h a) -> Mayb f m -> Mayb g m -> Mayb h m
zipMayb3 :: (forall a. f a -> g a -> h a -> i a) -> Mayb f m -> Mayb g m -> Mayb h m -> Mayb i m
class MaybeWit (c :: k -> Constraint) (m :: Maybe k)
maybeWit :: MaybeWit c m => Mayb (Wit1 c) m
instance forall k (f :: k -> *) (m :: GHC.Base.Maybe k). Data.Type.Mayb.MaybeC GHC.Show.Show (f Data.Type.Mayb.<$> m) => GHC.Show.Show (Data.Type.Mayb.Mayb f m)
instance forall k (c :: k -> GHC.Types.Constraint) (m :: GHC.Base.Maybe k). (Data.Type.Mayb.MaybeC c m, Type.Class.Known.Known (Data.Type.Mayb.Mayb Data.Type.Mayb.P) m) => Data.Type.Mayb.MaybeWit c m
instance forall k1 (k2 :: k1). Type.Class.Known.Known Data.Type.Mayb.P k2
instance forall k (m :: GHC.Base.Maybe k) (f :: k -> *). (Type.Class.Known.Known (Data.Type.Mayb.Mayb Data.Type.Mayb.P) m, Data.Type.Mayb.MaybeC GHC.Num.Num (f Data.Type.Mayb.<$> m)) => GHC.Num.Num (Data.Type.Mayb.Mayb f m)
instance forall k (m :: GHC.Base.Maybe k) (f :: k -> *). (Type.Class.Known.Known (Data.Type.Mayb.Mayb Data.Type.Mayb.P) m, Data.Type.Mayb.MaybeC GHC.Num.Num (f Data.Type.Mayb.<$> m), Data.Type.Mayb.MaybeC GHC.Real.Fractional (f Data.Type.Mayb.<$> m)) => GHC.Real.Fractional (Data.Type.Mayb.Mayb f m)
instance forall k (f :: k -> *). Type.Class.Known.Known (Data.Type.Mayb.Mayb f) 'GHC.Base.Nothing
instance forall a1 (f :: a1 -> *) (a2 :: a1). Type.Class.Known.Known f a2 => Type.Class.Known.Known (Data.Type.Mayb.Mayb f) ('GHC.Base.Just a2)
instance Type.Class.Higher.Functor1 Data.Type.Mayb.Mayb

module Backprop.Learn.Class

-- | Class for models that can be trained using gradient descent
--   
--   An instance <tt>l</tt> of <tt><a>Learn</a> a b</tt> is parameterized
--   by <tt>p</tt>, takes <tt>a</tt> as input, and returns <tt>b</tt> as
--   outputs. <tt>l</tt> can be thought of as a value containing the
--   <i>hyperparmaeters</i> of the model.
class (MaybeC Num (LParamMaybe l), MaybeC Num (LStateMaybe l), Num a, Num b, KnownMayb (LParamMaybe l), KnownMayb (LStateMaybe l)) => Learn a b l | l -> a, l -> b where {
    type family LParamMaybe l :: Maybe Type;
    type family LStateMaybe l :: Maybe Type;
    type LParamMaybe l =  'Nothing;
    type LStateMaybe l =  'Nothing;
}

-- | Initialize parameters, given the hyperparameters in <tt>l</tt>.
initParam :: (Learn a b l, PrimMonad m) => l -> Gen (PrimState m) -> LParam m l

-- | Initialize parameters, given the hyperparameters in <tt>l</tt>.
initParam :: (Learn a b l, (LParamMaybe l ~  'Nothing)) => l -> Gen (PrimState m) -> LParam m l

-- | Initialize state, given the hyperparameters in <tt>l</tt>.
initState :: (Learn a b l, PrimMonad m) => l -> Gen (PrimState m) -> LState m l

-- | Initialize state, given the hyperparameters in <tt>l</tt>.
initState :: (Learn a b l, (LStateMaybe l ~  'Nothing)) => l -> Gen (PrimState m) -> LState m l

-- | Run the model itself, deterministically.
--   
--   If your model has no state, you can define this conveniently using
--   <a>stateless</a>.
runLearn :: (Learn a b l, Reifies s W) => l -> LParam (BVar s) l -> BVar s a -> LState (BVar s) l -> (BVar s b, LState (BVar s) l)

-- | Run a model in stochastic mode.
--   
--   If model is inherently non-stochastic, a default implementation is
--   given in terms of <a>runLearn</a>.
--   
--   If your model has no state, you can define this conveniently using
--   <tt>statelessStoch</tt>.
runLearnStoch :: (Learn a b l, Reifies s W, PrimMonad m) => l -> Gen (PrimState m) -> LParam (BVar s) l -> BVar s a -> LState (BVar s) l -> m (BVar s b, LState (BVar s) l)

-- | The trainable parameter type of a model. Will be a compile-time error
--   if the model has no trainable parameters.
type LParamOf l = FromJust ( 'ShowType l :<>:  'Text " has no trainable parameters") (LParamMaybe l)

-- | The state type of a model. Will be a compile-time error if the model
--   has no state.
type LStateOf l = FromJust ( 'ShowType l :<>:  'Text " has no trainable parameters") (LStateMaybe l)

-- | Constraint specifying that a given model has no trainabale parameters.
type NoParam l = LParamMaybe l ~  'Nothing

-- | Constraint specifying that a given model has no state.
type NoState l = LStateMaybe l ~  'Nothing

-- | Is <a>N_</a> if there is <tt>l</tt> has no trainable parameters;
--   otherwise is <a>J_</a> with <tt>f p</tt>, for trainable parameter type
--   <tt>p</tt>.
type LParam f l = Mayb f (LParamMaybe l)

-- | Is <a>N_</a> if there is <tt>l</tt> has no state; otherwise is
--   <a>J_</a> with <tt>f s</tt>, for state type <tt>s</tt>.
type LState f l = Mayb f (LStateMaybe l)

-- | Useful for defining <a>runLearn</a> if your model has no state.
stateless :: (a -> b) -> (a -> s -> (b, s))

-- | Useful for defining <a>runLearnStoch</a> if your model has no state.
statelessM :: Functor m => (a -> m b) -> (a -> s -> m (b, s))
runLearnStateless :: (Learn a b l, Reifies s W, NoState l) => l -> LParam (BVar s) l -> BVar s a -> BVar s b
runLearnStochStateless :: (Learn a b l, Reifies s W, NoState l, PrimMonad m) => l -> Gen (PrimState m) -> LParam (BVar s) l -> BVar s a -> m (BVar s b)
data Mayb :: (k -> Type) -> Maybe k -> Type
[N_] :: Mayb f  'Nothing
[J_] :: f a -> Mayb f ( 'Just a)
fromJ_ :: Mayb f ( 'Just a) -> f a
type KnownMayb = Known (Mayb P)
knownMayb :: KnownMayb p => Mayb P p

module Backprop.Learn.Function

-- | A <tt><a>ParamFunc</a> p a b</tt> is a parameterized function from
--   <tt>a</tt> to <tt>b</tt>, potentially with trainable parameter
--   <tt>p</tt>.
data ParamFunc p a b
PF :: (forall m. PrimMonad m => Gen (PrimState m) -> Mayb m p) -> (forall s. Reifies s W => Mayb (BVar s) p -> BVar s a -> BVar s b) -> ParamFunc p a b
[_pfInit] :: ParamFunc p a b -> forall m. PrimMonad m => Gen (PrimState m) -> Mayb m p
[_pfFunc] :: ParamFunc p a b -> forall s. Reifies s W => Mayb (BVar s) p -> BVar s a -> BVar s b

-- | An unparameterized function. Has a <a>Category</a> instance.
type FixedFunc = ParamFunc  'Nothing

-- | Create a <a>ParamFunc</a> from any instance of <a>Learn</a> that does
--   not have state.
learnParam :: forall l a b. (Learn a b l, NoState l) => l -> ParamFunc (LParamMaybe l) a b

-- | Softmax normalizer
softMax :: KnownNat i => FixedFunc (R i) (R i)

-- | Logistic function, typically used as an activation function
logisticFunc :: Floating a => FixedFunc a a

-- | Scaling function
scaleFunc :: Num a => a -> FixedFunc a a

-- | Tanh function
tanhFunc :: Floating a => FixedFunc a a

-- | Map a differentiable function over every item in an <a>R</a>
mapFunc :: KnownNat i => (forall s. Reifies s W => BVar s Double -> BVar s Double) -> FixedFunc (R i) (R i)

-- | Rectified linear unit activation function
reLU :: KnownNat i => FixedFunc (R i) (R i)

-- | Exponential linear unit activation function
eLU :: KnownNat i => FixedFunc (R i) (R i)

-- | Scaling function, but with a trainable scaling parameter.
pScale :: (KnownNat i, ContGen d) => d -> ParamFunc ( 'Just Double) (R i) (R i)

-- | Map a parameterized differentiable function over ever item in an
--   <a>R</a>. The parameteri is trainable.
pMap :: (KnownNat i, Num p) => (forall m. PrimMonad m => Gen (PrimState m) -> m p) -> (forall s. Reifies s W => BVar s p -> BVar s Double -> BVar s Double) -> ParamFunc ( 'Just p) (R i) (R i)

-- | Compose two <a>ParamFunc</a>s on lists.
(.-) :: forall ps qs a b c. (ListC (Num <$> ps), ListC (Num <$> qs), Known Length ps, Known Length qs) => ParamFunc ( 'Just (T ps)) b c -> ParamFunc ( 'Just (T qs)) a b -> ParamFunc ( 'Just (T (ps ++ qs))) a c
infixr 9 .-

-- | The identity of <a>.-</a>
nilPF :: ParamFunc ( 'Just (T '[])) a a

-- | <a>ParamFunc</a> taking a singleton list; meant to be used with
--   <a>.-</a>
onlyPF :: forall p a b. (KnownMayb p, MaybeC Num p) => ParamFunc p a b -> ParamFunc ( 'Just (T (MaybeToList p))) a b
instance (GHC.Num.Num a, GHC.Num.Num b, Data.Type.Mayb.MaybeC GHC.Num.Num p, Data.Type.Mayb.KnownMayb p) => Backprop.Learn.Class.Learn a b (Backprop.Learn.Function.ParamFunc p a b)
instance (Data.Type.Mayb.MaybeC GHC.Num.Num p, Data.Type.Mayb.KnownMayb p) => Control.Category.Category (Backprop.Learn.Function.ParamFunc p)

module Backprop.Learn.FullyConnected

-- | Fully connected feed-forward layer with bias. Parameterized by its
--   initialization distribution.
newtype FC (i :: Nat) (o :: Nat)
FC :: (forall m. PrimMonad m => Gen (PrimState m) -> m Double) -> FC
[_fcGen] :: FC -> forall m. PrimMonad m => Gen (PrimState m) -> m Double

-- | Construct an <tt><a>FC</a> i o</tt> using a given distribution from
--   the <i>statistics</i> library.
fc :: ContGen d => d -> FC i o

-- | Fully connected feed-forward layer parameters.
data FCP i o
FCP :: !(R o) -> !(L o i) -> FCP i o
[_fcBias] :: FCP i o -> !(R o)
[_fcWeights] :: FCP i o -> !(L o i)
fcBias :: Functor f => (R o -> f (R o)) -> FCP i o -> f (FCP i o)
fcWeights :: Functor f => (L o i -> f (L o k)) -> FCP i o -> f (FCP k o)
instance GHC.Generics.Generic (Backprop.Learn.FullyConnected.FCP i o)
instance (GHC.TypeNats.KnownNat i, GHC.TypeNats.KnownNat o) => GHC.Num.Num (Backprop.Learn.FullyConnected.FCP i o)
instance (GHC.TypeNats.KnownNat i, GHC.TypeNats.KnownNat o) => Backprop.Learn.Class.Learn (Internal.Static.R i) (Internal.Static.R o) (Backprop.Learn.FullyConnected.FC i o)

module Backprop.Learn.Dropout

-- | Dropout layer. Parameterized by dropout percentage (should be between
--   0 and 1).
--   
--   0 corresponds to no dropout, 1 corresponds to complete dropout of all
--   nodes every time.
newtype DO (n :: Nat)
DO :: Double -> DO
[_doRate] :: DO -> Double
instance GHC.TypeNats.KnownNat n => Backprop.Learn.Class.Learn (Internal.Static.R n) (Internal.Static.R n) (Backprop.Learn.Dropout.DO n)
