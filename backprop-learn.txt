-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators and useful tools for ANNs using the backprop library
--   
--   See README.md
@package backprop-learn
@version 0.1.0.0

module Backprop.Learn.Class

-- | Class for models that can be trained using gradient descent.
--   
--   An instance <tt>l</tt> of <tt><a>Learn</a> p a b</tt> is parameterized
--   by <tt>p</tt>, takes <tt>a</tt> as input, and returns <tt>b</tt> as
--   outputs.
--   
--   <tt>l</tt> can be thought of as representing the
--   <i>hyperparameters</i> of the model, with <tt>p</tt> representing the
--   <i>trained parameters</i> of the model.
--   
--   If no trained parameters exist, <a>NoParam</a> can be used. This will
--   automatically derive <a>initParam</a>.
class (Num p, Num a, Num b) => Learn p a b l | l -> p, l -> a, l -> b

-- | Initialization of trainiable model parameters.
initParam :: (Learn p a b l, PrimMonad m) => l -> Gen (PrimState m) -> m p

-- | Initialization of trainiable model parameters.
initParam :: (Learn p a b l, PrimMonad m, p ~ NoParam) => l -> Gen (PrimState m) -> m p

-- | Run the model.
runFixed :: (Learn p a b l, Reifies s W) => l -> BVar s p -> BVar s a -> BVar s b

-- | Running the model in "stochastic" mode.
--   
--   For nonstochastic models, is automatically defined in terms of
--   <a>runFixed</a>.
runStoch :: (Learn p a b l, PrimMonad m, Reifies s W) => l -> Gen (PrimState m) -> BVar s p -> BVar s a -> m (BVar s b)

-- | Useful convenience type for trained models without learnable
--   parameters. Can be used to automatically derive <a>initParam</a> if
--   given as a model's parmaeters.
type NoParam = T0

module Backprop.Learn

-- | Chain components linearly, retaining the ability to deconstruct at a
--   later time.
data Chain :: [Type] -> [Type] -> Type -> Type -> Type
[CNil] :: Chain '[] '[] a a
[:~>] :: (Learn p a b l, Num b) => l -> Chain ls ps b c -> Chain (l : ls) (p : ps) a c
(~:++) :: forall ls ks ps qs a b c. (Known Length ps, Known Length qs, ListC (Num <$> ps), ListC (Num <$> qs)) => Chain ls ps a b -> Chain ks qs b c -> Chain (ls ++ ks) (ps ++ qs) a c
infixl 5 ~:++

-- | Data type representing trainable models.
--   
--   Useful for performant composition, but you lose the ability to
--   decompose parts.
data LearnFunc :: Type -> Type -> Type -> Type
[LF] :: {_lfInitParam :: forall m. PrimMonad m => Gen (PrimState m) -> m p, _lfRunFixed :: forall s. Reifies s W => BVar s p -> BVar s a -> BVar s b, _lfRunStoch :: forall m s. (PrimMonad m, Reifies s W) => Gen (PrimState m) -> BVar s p -> BVar s a -> m (BVar s b)} -> LearnFunc p a b
learnFunc :: Learn p a b l => l -> LearnFunc p a b
(~~>) :: (Num p, ListC (Num <$> ps), Known Length ps) => LearnFunc p a b -> LearnFunc (T ps) b c -> LearnFunc (T (p : ps)) a c
infixr 5 ~~>
nilLF :: LearnFunc (T '[]) a a
(~!>) :: LearnFunc NoParam a b -> LearnFunc p b c -> LearnFunc p a c
infixr 5 ~!>
(~>!) :: LearnFunc (T ps) a b -> LearnFunc NoParam b c -> LearnFunc (T ps) a c
infixr 5 ~>!
(~++) :: forall ps qs a b c. (Known Length ps, Known Length qs, ListC (Num <$> ps), ListC (Num <$> qs)) => LearnFunc (T ps) a b -> LearnFunc (T qs) b c -> LearnFunc (T (ps ++ qs)) a c
parLF :: (Num p, Num q, Num a, Num b, Num c, Num d) => LearnFunc p a c -> LearnFunc q b d -> LearnFunc (T2 p q) (T2 a b) (T2 c d)
compLF :: (Num p, Num q) => LearnFunc p b c -> LearnFunc q a b -> LearnFunc (T2 p q) a c

-- | Simple composition of <a>Learn</a> instances
data l (:.~) k
instance (Backprop.Learn.Class.Learn p b c l, Backprop.Learn.Class.Learn q a b k) => Backprop.Learn.Class.Learn (Numeric.Backprop.Tuple.T2 p q) a c (l Backprop.Learn.:.~ k)
instance (GHC.Num.Num p, GHC.Num.Num a, GHC.Num.Num b) => Backprop.Learn.Class.Learn p a b (Backprop.Learn.LearnFunc p a b)
instance GHC.Num.Num p => Control.Category.Category * (Backprop.Learn.LearnFunc p)
instance (Type.Family.List.ListC ((Type.Family.List.<$>) * GHC.Types.Constraint GHC.Num.Num ps), Type.Class.Known.Known [*] (Data.Type.Length.Length *) ps, GHC.Num.Num a, GHC.Num.Num b) => Backprop.Learn.Class.Learn (Numeric.Backprop.Tuple.T ps) a b (Backprop.Learn.Chain ls ps a b)

module Backprop.Learn.Dropout
instance GHC.TypeNats.KnownNat n => Backprop.Learn.Class.Learn Backprop.Learn.Class.NoParam (Internal.Static.R n) (Internal.Static.R n) (Backprop.Learn.Dropout.DO n)

module Backprop.Learn.FullyConnected

-- | Fully connected feed-forward layer with bias. Parameterized by its
--   initialization distribution.
newtype FC (i :: Nat) (o :: Nat)
FC :: (forall m. PrimMonad m => Gen (PrimState m) -> m Double) -> FC
[_fcGen] :: FC -> forall m. PrimMonad m => Gen (PrimState m) -> m Double

-- | Construct an <tt><a>FC</a> i o</tt> using a given distribution from
--   the <i>statistics</i> library.
fc :: ContGen d => d -> FC i o

-- | Fully connected feed-forward layer parameters.
data FCP i o
FCP :: !(R o) -> !(L o i) -> FCP i o
[_fcBias] :: FCP i o -> !(R o)
[_fcWeights] :: FCP i o -> !(L o i)
fcBias :: Functor f => (R o -> f (R o)) -> FCP i o -> f (FCP i o)
fcWeights :: Functor f => (L o i -> f (L o k)) -> FCP i o -> f (FCP k o)
instance GHC.Generics.Generic (Backprop.Learn.FullyConnected.FCP i o)
instance (GHC.TypeNats.KnownNat i, GHC.TypeNats.KnownNat o) => GHC.Num.Num (Backprop.Learn.FullyConnected.FCP i o)
instance (GHC.TypeNats.KnownNat i, GHC.TypeNats.KnownNat o) => Backprop.Learn.Class.Learn (Backprop.Learn.FullyConnected.FCP i o) (Internal.Static.R i) (Internal.Static.R o) (Backprop.Learn.FullyConnected.FC i o)

module Backprop.Learn.Function
newtype FixedFunc a b
FF :: (forall s. Reifies s W => BVar s a -> BVar s b) -> FixedFunc a b
[runFixedFunc] :: FixedFunc a b -> forall s. Reifies s W => BVar s a -> BVar s b
data ParamFunc p a b
PF :: (forall m. PrimMonad m => Gen (PrimState m) -> m p) -> (forall s. Reifies s W => BVar s p -> BVar s a -> BVar s b) -> ParamFunc p a b
[_pfInit] :: ParamFunc p a b -> forall m. PrimMonad m => Gen (PrimState m) -> m p
[_pfFunc] :: ParamFunc p a b -> forall s. Reifies s W => BVar s p -> BVar s a -> BVar s b
compPF :: (Num p, Num q) => ParamFunc p b c -> ParamFunc q a b -> ParamFunc (T2 p q) a c
parPF :: (Num p, Num q, Num a, Num b, Num c, Num d) => ParamFunc p a c -> ParamFunc q b d -> ParamFunc (T2 p q) (T2 a b) (T2 c d)
idPF :: ParamFunc NoParam a a
fixedParam :: FixedFunc a b -> ParamFunc NoParam a b
learnParam :: Learn p a b l => l -> ParamFunc p a b
nilPF :: ParamFunc (T '[]) a a
(-~>) :: (Known Length ps, ListC (Num <$> ps), Num p) => ParamFunc p a b -> ParamFunc (T ps) b c -> ParamFunc (T (p : ps)) a c
infixr 5 -~>
(-!>) :: FixedFunc a b -> ParamFunc p b c -> ParamFunc p a c
infixr 5 -!>
(->!) :: ParamFunc p a b -> FixedFunc b c -> ParamFunc p a c
infixr 5 ->!
(-++) :: forall ps qs a b c. (Known Length ps, Known Length qs, ListC (Num <$> ps), ListC (Num <$> qs)) => ParamFunc (T ps) a b -> ParamFunc (T qs) b c -> ParamFunc (T (ps ++ qs)) a c
infixr 5 -++
softMax :: KnownNat i => FixedFunc (R i) (R i)
logisticFunc :: Floating a => FixedFunc a a
scaleFunc :: Num a => a -> FixedFunc a a
tanhFunc :: Floating a => FixedFunc a a
mapFunc :: KnownNat i => (forall s. Reifies s W => BVar s Double -> BVar s Double) -> FixedFunc (R i) (R i)
reLU :: KnownNat i => FixedFunc (R i) (R i)
eLU :: KnownNat i => FixedFunc (R i) (R i)
pScale :: (KnownNat i, ContGen d) => d -> ParamFunc Double (R i) (R i)
pMap :: KnownNat i => (forall m. PrimMonad m => Gen (PrimState m) -> m p) -> (forall s. Reifies s W => BVar s p -> BVar s Double -> BVar s Double) -> ParamFunc p (R i) (R i)
instance (GHC.Num.Num p, GHC.Num.Num a, GHC.Num.Num b) => Backprop.Learn.Class.Learn p a b (Backprop.Learn.Function.ParamFunc p a b)
instance GHC.Num.Num p => Control.Category.Category * (Backprop.Learn.Function.ParamFunc p)
instance (GHC.Num.Num a, GHC.Num.Num b) => Backprop.Learn.Class.Learn Backprop.Learn.Class.NoParam a b (Backprop.Learn.Function.FixedFunc a b)
instance Control.Category.Category * Backprop.Learn.Function.FixedFunc
