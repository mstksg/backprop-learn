-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators and useful tools for ANNs using the backprop library
--   
--   See README.md
@package backprop-learn
@version 0.1.0.0

module Numeric.Tensor
class SingKind k => Tensor (t :: k -> Type) where type IndexT t :: k -> Type type ElemT t :: Type where {
    type family IndexT t :: k -> Type;
    type family ElemT t :: Type;
}
genA :: (Tensor t, Applicative f) => Sing s -> (IndexT t s -> f (ElemT t)) -> f (t s)
gen :: Tensor t => Sing s -> (IndexT t s -> ElemT t) -> t s
tkonst :: Tensor t => Sing s -> ElemT t -> t s
tsum :: (Tensor t, SingI s) => t s -> ElemT t
tmap :: (Tensor t, SingI s) => (ElemT t -> ElemT t) -> t s -> t s
tzip :: (Tensor t, SingI s) => (ElemT t -> ElemT t -> ElemT t) -> t s -> t s -> t s

module Numeric.BLAS
class BLAS (b :: BShape Nat -> Type) where type Scalar b :: Type where {
    type family Scalar b :: Type;
}
scal :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BV n)
axpy :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BV n) -> b (BV n)
dot :: (BLAS b, KnownNat n) => b (BV n) -> b (BV n) -> Scalar b
norm2 :: (BLAS b, KnownNat n) => b (BV n) -> Scalar b
asum :: (BLAS b, KnownNat n) => b (BV n) -> Scalar b
iamax :: (BLAS b, KnownNat n) => b (BV n) -> Finite n
gemv :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BM m n) -> b (BV n) -> Scalar b -> b (BV m) -> b (BV m)
ger :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BV m) -> b (BV n) -> b (BM m n) -> b (BM m n)
syr :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BM n n) -> b (BM n n)
gemm :: (BLAS b, KnownNat m, KnownNat o, KnownNat n) => Scalar b -> b (BM m o) -> b (BM o n) -> Scalar b -> b (BM m n) -> b (BM m n)
syrk :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BM m n) -> Scalar b -> b (BM m m) -> b (BM m m)
data BShape a_anhz
BV :: !a_anhz -> BShape a_anhz
BM :: !a_anhz -> !a_anhz -> BShape a_anhz

-- | The singleton kind-indexed data family.
type SBShape = (Sing :: BShape a_anhz -> Type)
data BIndex :: BShape Nat -> Type
[BVIx] :: Finite n -> BIndex (BV n)
[BMIx] :: Finite m -> Finite n -> BIndex (BM m n)
instance GHC.Base.Functor Numeric.BLAS.BShape
instance GHC.Classes.Ord a0 => GHC.Classes.Ord (Numeric.BLAS.BShape a0)
instance GHC.Classes.Eq a0 => GHC.Classes.Eq (Numeric.BLAS.BShape a0)
instance GHC.Show.Show a0 => GHC.Show.Show (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Eq.PEq 'Data.Proxy.Proxy
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BVSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BMSym1
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BMSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.Compare_6989586621679106245Sym1
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.Compare_6989586621679106245Sym0
instance Data.Singletons.Prelude.Ord.POrd 'Data.Proxy.Proxy
instance Data.Singletons.SingKind a0 => Data.Singletons.SingKind (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Eq.SEq a0 => Data.Singletons.Prelude.Eq.SEq (Numeric.BLAS.BShape a0)
instance Data.Singletons.Decide.SDecide a0 => Data.Singletons.Decide.SDecide (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Ord.SOrd a0 => Data.Singletons.Prelude.Ord.SOrd (Numeric.BLAS.BShape a0)
instance forall a0 (n0 :: a0). Data.Singletons.SingI n0 => Data.Singletons.SingI ('Numeric.BLAS.BV n0)
instance forall a0 (n0 :: a0) (n1 :: a0). (Data.Singletons.SingI n0, Data.Singletons.SingI n1) => Data.Singletons.SingI ('Numeric.BLAS.BM n0 n1)

module Numeric.BLAS.HMatrix
newtype HM :: BShape Nat -> Type
[HM] :: {getHM :: HM' b} -> HM b
instance Numeric.BLAS.BLAS Numeric.BLAS.HMatrix.HM
instance Numeric.Tensor.Tensor Numeric.BLAS.HMatrix.HM
instance Data.Singletons.SingI s => Data.MonoTraversable.MonoFunctor (Numeric.BLAS.HMatrix.HM s)
instance Data.Singletons.SingI s => Data.MonoTraversable.MonoFoldable (Numeric.BLAS.HMatrix.HM s)

module Learn.Neural
data Statefulness
Stateful :: Statefulness
NonStateful :: Statefulness
class Component (c :: (BShape Nat -> Type) -> BShape Nat -> BShape Nat -> Type) where type CState c (b :: BShape Nat -> Type) (i :: BShape Nat) (o :: BShape Nat) :: Maybe Type where {
    type family CState c
                       (b :: BShape Nat -> Type)
                       (i :: BShape Nat)
                       (o :: BShape Nat) :: Maybe Type;
}
runComponent :: Component c => OpB t (b i : (c b i o : MaybeToList (CState c b i o))) (b o : MaybeToList (CState c b i o))
initComponent :: (Component c, ContGen d) => Sing i -> Sing o -> d -> Gen (PrimState m) -> m (c b i o, Option I (CState c b i o))
data Params :: Statefulness -> ((BShape Nat -> Type) -> BShape Nat -> BShape Nat -> Type) -> (BShape Nat -> Type) -> BShape Nat -> BShape Nat -> Type
[PPure] :: (Num (c b i o), Component c, CState c b i o ~ Nothing) => c b i o -> Params s c b i o
[PStateful] :: (Num (c b i o), Num st, Component c, CState c b i o ~ Just st) => c b i o -> st -> Params Stateful c b i o
pPure :: (CState c b i o ~ Nothing, Num (c b i o), Component c) => Iso' (Params s c b i o) (c b i o)
pStateful :: (CState c b i o ~ Just st, Num (c b i o), Num st, Component c) => Iso' (Params Stateful c b i o) (Tuple '[c b i o, st])
paramsOpPure :: forall s sf c b i o. (Num (b o), CState c b i o ~ Nothing, Component c, Num (c b i o)) => BPOp s '[b i, Params sf c b i o] '[b o]
paramsOp :: forall s sf c b i o. Num (b o) => BPOp s '[b i, Params sf c b i o] '[b o, Params sf c b i o]
data Network :: Statefulness -> (BShape Nat -> Type) -> (BShape Nat, (BShape Nat -> Type) -> BShape Nat -> BShape Nat -> Type) -> [(BShape Nat, (BShape Nat -> Type) -> BShape Nat -> BShape Nat -> Type)] -> BShape Nat -> Type
[NetExt] :: Params s c b i o -> Network s b '(i, c) '[] o
[:&] :: (Num (b h), Component d) => Params s c b i h -> Network s b '(h, d) hs o -> Network s b '(i, c) ('(h, d) : hs) o
netExt :: Iso' (Network s b '(i, c) '[] o) (Params s c b i o)
netInt :: (Num (b h), Component d) => Iso' (Network s b '(i, c) ('(h, d) : hs) o) (Tuple '[Params s c b i h, Network s b '(h, d) hs o])
networkOp :: (Num (b i), Component c, Num (b o)) => BPOp s '[b i, Network sf b '(i, c) hs o] '[b o, Network sf b '(i, c) hs o]
instance Learn.Neural.Component c => GHC.Num.Num (Learn.Neural.Params s c b i o)
instance GHC.Num.Num (Learn.Neural.Network s b i hs o)
