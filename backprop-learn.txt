-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators and useful tools for ANNs using the backprop library
--   
--   Combinators and useful tools for ANNs using the backprop library
@package backprop-learn
@version 0.1.0.0

module Numeric.Tensor
class SingKind k => Tensor (t :: k -> Type) where type IndexT t :: k -> Type type ElemT t :: Type where {
    type family IndexT t :: k -> Type;
    type family ElemT t :: Type;
}
genA :: (Tensor t, Applicative f) => Sing s -> (IndexT t s -> f (ElemT t)) -> f (t s)
gen :: Tensor t => Sing s -> (IndexT t s -> ElemT t) -> t s
tkonst :: Tensor t => Sing s -> ElemT t -> t s
tsum :: (Tensor t, SingI s) => t s -> ElemT t
tmap :: (Tensor t, SingI s) => (ElemT t -> ElemT t) -> t s -> t s
tzip :: (Tensor t, SingI s) => (ElemT t -> ElemT t -> ElemT t) -> t s -> t s -> t s

module Numeric.BLAS
class BLAS (b :: BShape Nat -> Type) where type Scalar b :: Type where {
    type family Scalar b :: Type;
}
scal :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BV n)
axpy :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BV n) -> b (BV n)
dot :: (BLAS b, KnownNat n) => b (BV n) -> b (BV n) -> Scalar b
norm2 :: (BLAS b, KnownNat n) => b (BV n) -> Scalar b
asum :: (BLAS b, KnownNat n) => b (BV n) -> Scalar b
iamax :: (BLAS b, KnownNat n) => b (BV n) -> Finite n
gemv :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BM m n) -> b (BV n) -> Scalar b -> b (BV m) -> b (BV m)
ger :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BV m) -> b (BV n) -> b (BM m n) -> b (BM m n)
syr :: (BLAS b, KnownNat n) => Scalar b -> b (BV n) -> b (BM n n) -> b (BM n n)
gemm :: (BLAS b, KnownNat m, KnownNat o, KnownNat n) => Scalar b -> b (BM m o) -> b (BM o n) -> Scalar b -> b (BM m n) -> b (BM m n)
syrk :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b (BM m n) -> Scalar b -> b (BM m m) -> b (BM m m)
data BShape a_akvg
BV :: !a_akvg -> BShape a_akvg
BM :: !a_akvg -> !a_akvg -> BShape a_akvg

-- | The singleton kind-indexed data family.
type SBShape = (Sing :: BShape a_akvg -> Type)
data BIndex :: BShape Nat -> Type
[BVIx] :: Finite n -> BIndex (BV n)
[BMIx] :: Finite m -> Finite n -> BIndex (BM m n)
instance GHC.Base.Functor Numeric.BLAS.BShape
instance GHC.Classes.Ord a0 => GHC.Classes.Ord (Numeric.BLAS.BShape a0)
instance GHC.Classes.Eq a0 => GHC.Classes.Eq (Numeric.BLAS.BShape a0)
instance GHC.Show.Show a0 => GHC.Show.Show (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Eq.PEq 'Data.Proxy.Proxy
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BVSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BMSym1
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.BMSym0
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.Compare_6989586621679095562Sym1
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Numeric.BLAS.Compare_6989586621679095562Sym0
instance Data.Singletons.Prelude.Ord.POrd 'Data.Proxy.Proxy
instance Data.Singletons.SingKind a0 => Data.Singletons.SingKind (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Eq.SEq a0 => Data.Singletons.Prelude.Eq.SEq (Numeric.BLAS.BShape a0)
instance Data.Singletons.Decide.SDecide a0 => Data.Singletons.Decide.SDecide (Numeric.BLAS.BShape a0)
instance Data.Singletons.Prelude.Ord.SOrd a0 => Data.Singletons.Prelude.Ord.SOrd (Numeric.BLAS.BShape a0)
instance forall a0 (n0 :: a0). Data.Singletons.SingI n0 => Data.Singletons.SingI ('Numeric.BLAS.BV n0)
instance forall a0 (n0 :: a0) (n1 :: a0). (Data.Singletons.SingI n0, Data.Singletons.SingI n1) => Data.Singletons.SingI ('Numeric.BLAS.BM n0 n1)

module Numeric.BLAS.HMatrix
newtype HM :: BShape Nat -> Type
[HM] :: {getHM :: HM' b} -> HM b
instance Numeric.BLAS.BLAS Numeric.BLAS.HMatrix.HM
instance Numeric.Tensor.Tensor Numeric.BLAS.HMatrix.HM
instance Data.Singletons.SingI s => Data.MonoTraversable.MonoFunctor (Numeric.BLAS.HMatrix.HM s)
instance Data.Singletons.SingI s => Data.MonoTraversable.MonoFoldable (Numeric.BLAS.HMatrix.HM s)
