-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators and useful tools for ANNs using the backprop library
--   
--   See README.md
@package backprop-learn
@version 0.1.0.0

module Numeric.Tensor
class RealFloat (Scalar t) => Tensor (t :: [Nat] -> Type) where type Scalar t :: Type gen s f = getI $ genA s (I . f) tkonst s x = gen s $ \ _ -> x tmap f x = tzipN (\case { I x' :* ØV -> f x' }) (x :* ØV) tzip f x y = tzipN (\case { I x' :* I y' :* ØV -> f x' y' }) (x :* y :* ØV) tzipN f xs = gen sing $ \ i -> f $ vmap (I . tindex i) xs treshape s = tload s . textract tload s = fromJust . fromList' s . toList where {
    type family Scalar t :: Type;
}
genA :: forall f s. (Tensor t, Applicative f) => Sing s -> (Prod Finite s -> f (Scalar t)) -> f (t s)
gen :: forall s. Tensor t => Sing s -> (Prod Finite s -> Scalar t) -> t s
tkonst :: Tensor t => Sing s -> Scalar t -> t s
tsum :: (Tensor t, SingI s) => t s -> Scalar t
tmap :: (Tensor t, SingI s) => (Scalar t -> Scalar t) -> t s -> t s
tzip :: (Tensor t, SingI s) => (Scalar t -> Scalar t -> Scalar t) -> t s -> t s -> t s
tzipN :: (Tensor t, SingI s) => (Vec n (Scalar t) -> Scalar t) -> VecT n t s -> t s
tsize :: (Tensor t, SingI s) => t s -> Int
tindex :: (Tensor t, SingI s) => Prod Finite s -> t s -> Scalar t
tconv :: Tensor t => Sing n -> ProdMap Conv m s -> t (m >: n) -> t s -> t (s >: n)
tslice :: Tensor t => ProdMap Slice n m -> t n -> t m
treshape :: (Tensor t, SingI s1, Product s1 ~ Product s2) => Sing s2 -> t s1 -> t s2
tload :: Tensor t => Sing s -> Vector (Product s) (Scalar t) -> t s
textract :: (Tensor t, SingI s) => t s -> Vector (Product s) (Scalar t)
data ProdMap :: (a -> b -> Type) -> [a] -> [b] -> Type
[PMZ] :: ProdMap f '[] '[]
[PMS] :: f a b -> ProdMap f as bs -> ProdMap f (a : as) (b : bs)
data Slice :: Nat -> Nat -> Type
[Slice] :: Sing l -> Sing c -> Sing r -> Slice ((l + c) + r) c
data Conv :: Nat -> Nat -> Type
[Conv] :: {convMaskDim :: Sing m, convImageDim :: Sing s, convStride :: Finite s, convOffset :: Finite s} -> Conv m s
sProduct :: Sing as -> Sing (Product as)
fromScalar :: Tensor t => Scalar t -> t '[]
toScalar :: Tensor t => t '[] -> Scalar t
fromList' :: Tensor t => Sing s -> [Scalar t] -> Maybe (t s)
fromList :: Tensor t => Sing s -> [Scalar t] -> Maybe (t s)
tmapOp :: (Tensor t, SingI s) => (forall q. AD q (Forward (Scalar t)) -> AD q (Forward (Scalar t))) -> Op '[t s] '[t s]
tzipNOp :: forall t s n. (Tensor t, SingI s, Known Nat n) => (forall q. Reifies q Tape => Vec n (Reverse q (Scalar t)) -> Reverse q (Scalar t)) -> Op (Replicate n (t s)) '[t s]
tkonstOp :: forall t s. Tensor t => Sing s -> Op '[Scalar t] '[t s]
tsumOp :: forall t s. (Tensor t, SingI s) => Op '[t s] '[Scalar t]
scaleOp :: forall t s. (Tensor t, SingI s, Num (t s)) => Op '[Scalar t, t s] '[t s]
oneHot :: (Tensor t, SingI s) => Prod Finite s -> t s

-- | Finite number type. <tt><a>Finite</a> n</tt> is inhabited by exactly
--   <tt>n</tt> values. Invariants:
--   
--   <pre>
--   getFinite x &lt; natVal x
--   </pre>
--   
--   <pre>
--   getFinite x &gt;= 0
--   </pre>
data Finite (n :: Nat) :: Nat -> *
instance forall k (f :: k -> GHC.Types.Type). Type.Class.Known.Known (Numeric.Tensor.DoubleProd f '[]) '[]
instance forall a (f :: a -> GHC.Types.Type) (as :: [a]) (bs :: [a]) (a1 :: a) (b :: a). (Type.Class.Known.Known (Numeric.Tensor.DoubleProd f as) bs, Type.Class.Known.Known f a1, Type.Class.Known.Known f b) => Type.Class.Known.Known (Numeric.Tensor.DoubleProd f (a1 : as)) (b : bs)

module Numeric.BLAS
class Tensor b => BLAS (b :: [Nat] -> Type)
transp :: (BLAS b, KnownNat m, KnownNat n) => b '[m, n] -> b '[n, m]
scal :: (BLAS b, KnownNat n) => Scalar b -> b '[n] -> b '[n]
axpy :: (BLAS b, KnownNat n) => Scalar b -> b '[n] -> b '[n] -> b '[n]
dot :: (BLAS b, KnownNat n) => b '[n] -> b '[n] -> Scalar b
norm2 :: (BLAS b, KnownNat n) => b '[n] -> Scalar b
asum :: (BLAS b, KnownNat n) => b '[n] -> Scalar b
iamax :: (BLAS b, KnownNat n) => b '[n] -> Finite n
gemv :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b '[m, n] -> b '[n] -> Maybe (Scalar b, b '[m]) -> b '[m]
ger :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b '[m] -> b '[n] -> Maybe (b '[m, n]) -> b '[m, n]
syr :: (BLAS b, KnownNat n) => Scalar b -> b '[n] -> b '[n, n] -> b '[n, n]
gemm :: (BLAS b, KnownNat m, KnownNat o, KnownNat n) => Scalar b -> b '[m, o] -> b '[o, n] -> Maybe (Scalar b, b '[m, n]) -> b '[m, n]
syrk :: (BLAS b, KnownNat m, KnownNat n) => Scalar b -> b '[m, n] -> Scalar b -> b '[m, m] -> b '[m, m]
matVec :: (KnownNat m, KnownNat n, BLAS b) => b '[m, n] -> b '[n] -> b '[m]
vecMat :: (KnownNat m, KnownNat n, BLAS b) => b '[m] -> b '[m, n] -> b '[n]
outer :: (KnownNat m, KnownNat n, BLAS b) => b '[m] -> b '[n] -> b '[m, n]
amax :: (BLAS b, KnownNat n) => b '[n] -> Scalar b
concretize :: (BLAS b, KnownNat n) => b '[n] -> b '[n]
matVecOp :: (KnownNat m, KnownNat n, BLAS b) => Op '[b '[m, n], b '[n]] '[b '[m]]
dotOp :: forall b n. (KnownNat n, BLAS b) => Op '[b '[n], b '[n]] '[Scalar b]
asumOp :: forall b n. (KnownNat n, BLAS b, Num (b '[n])) => Op '[b '[n]] '[Scalar b]

module Learn.Neural.Layer
class (Fractional (CParam c b i o), Fractional (CState c b i o), BLAS b) => Component (c :: Type) (b :: [Nat] -> Type) (i :: [Nat]) (o :: [Nat]) where data CParam c b i o :: Type data CState c b i o :: Type type CConstr c b i o :: Constraint data CConf c b i o :: Type type CConstr c b i o = ØC where {
    data family CParam c b i o :: Type;
    data family CState c b i o :: Type;
    type family CConstr c b i o :: Constraint;
    data family CConf c b i o :: Type;
    type CConstr c b i o = ØC;
}
componentOp :: forall s. (Component c b i o, Num (b i), Num (b o), CConstr c b i o) => OpB s '[b i, CParam c b i o, CState c b i o] '[b o, CState c b i o]
initParam :: forall m. (Component c b i o, PrimMonad m, CConstr c b i o) => Sing i -> Sing o -> CConf c b i o -> Gen (PrimState m) -> m (CParam c b i o)
initState :: forall m. (Component c b i o, PrimMonad m, CConstr c b i o) => Sing i -> Sing o -> CConf c b i o -> Gen (PrimState m) -> m (CState c b i o)
defConf :: Component c b i o => CConf c b i o
class Component c b i o => ComponentFF c b i o
componentOpFF :: forall s. (ComponentFF c b i o, Num (b i), Num (b o), CConstr c b i o) => OpB s '[b i, CParam c b i o] '[b o]
componentOpDefault :: forall c b i o s. (ComponentFF c b i o, BLAS b, Num (b i), Num (b o), CConstr c b i o, Num (CParam c b i o), Num (CState c b i o)) => OpB s '[b i, CParam c b i o, CState c b i o] '[b o, CState c b i o]
data RunMode
FeedForward :: RunMode
Recurrent :: RunMode
data Layer :: RunMode -> Type -> ([Nat] -> Type) -> [Nat] -> [Nat] -> Type
[LFeedForward] :: ComponentFF c b i o => CParam c b i o -> Layer r c b i o
[LRecurrent] :: CParam c b i o -> CState c b i o -> Layer Recurrent c b i o
data RunModeWit :: RunMode -> Type -> ([Nat] -> Type) -> [Nat] -> [Nat] -> Type
[RMIsFF] :: ComponentFF c b i o => RunModeWit r c b i o
[RMNotFF] :: RunModeWit Recurrent c b i o
class Component c b i o => ComponentLayer (r :: RunMode) c b i o
componentRunMode :: ComponentLayer r c b i o => RunModeWit r c b i o
layerOp :: forall r c i o b s. (Component c b i o, BLAS b, Num (b i), Num (b o), CConstr c b i o) => OpB s '[Layer r c b i o, b i] '[Layer r c b i o, b o]
layerOpPure :: forall c i o b s. (Component c b i o, BLAS b, Num (b i), Num (b o), CConstr c b i o) => OpB s '[Layer FeedForward c b i o, b i] '[b o]
initLayer :: forall r c b i o m. (PrimMonad m, BLAS b, ComponentLayer r c b i o, CConstr c b i o) => Sing i -> Sing o -> CConf c b i o -> Gen (PrimState m) -> m (Layer r c b i o)
instance Learn.Neural.Layer.ComponentLayer r c b i o => GHC.Num.Num (Learn.Neural.Layer.Layer r c b i o)
instance Learn.Neural.Layer.ComponentLayer r c b i o => GHC.Real.Fractional (Learn.Neural.Layer.Layer r c b i o)

module Learn.Neural.Layer.Applying
data Applying :: k -> Type
newtype TensorOp :: [Nat] -> [Nat] -> Type
[TF] :: {getTensorOp :: forall b s. (BLAS b, Num (b i), Num (b o)) => OpB s '[b i] '[b o]} -> TensorOp i o
data CommonOp :: Type
[TO_Softmax] :: [Nat] -> CommonOp
type SoftMax i = Applying (TO_Softmax i)
instance forall k (s :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]) (o :: [GHC.Types.Nat]). GHC.Num.Num (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Applying.Applying s) b i o)
instance forall k (s :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]) (o :: [GHC.Types.Nat]). GHC.Real.Fractional (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Applying.Applying s) b i o)
instance forall k (s :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]) (o :: [GHC.Types.Nat]). GHC.Num.Num (Learn.Neural.Layer.CState (Learn.Neural.Layer.Applying.Applying s) b i o)
instance forall k (s :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]) (o :: [GHC.Types.Nat]). GHC.Real.Fractional (Learn.Neural.Layer.CState (Learn.Neural.Layer.Applying.Applying s) b i o)
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (i :: [GHC.Types.Nat]) (o :: [GHC.Types.Nat]). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s (Learn.Neural.Layer.Applying.TensorOp i o), Data.Singletons.SingI i, Data.Singletons.SingI o) => Learn.Neural.Layer.Component (Learn.Neural.Layer.Applying.Applying s) b i o
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (i :: [GHC.Types.Nat]) (o :: [GHC.Types.Nat]). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s (Learn.Neural.Layer.Applying.TensorOp i o), Data.Singletons.SingI i, Data.Singletons.SingI o) => Learn.Neural.Layer.ComponentFF (Learn.Neural.Layer.Applying.Applying s) b i o
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (i :: [GHC.Types.Nat]) (o :: [GHC.Types.Nat]) (r :: Learn.Neural.Layer.RunMode). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s (Learn.Neural.Layer.Applying.TensorOp i o), Data.Singletons.SingI i, Data.Singletons.SingI o) => Learn.Neural.Layer.ComponentLayer r (Learn.Neural.Layer.Applying.Applying s) b i o
instance Data.Singletons.SingI i => Data.Reflection.Reifies ('Learn.Neural.Layer.Applying.TO_Softmax i) (Learn.Neural.Layer.Applying.TensorOp i i)

module Learn.Neural.Layer.FullyConnected
data FullyConnected :: Type
instance GHC.Generics.Generic (Learn.Neural.Layer.CParam Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o])
instance (GHC.Num.Num (b '[o, i]), GHC.Num.Num (b '[o])) => GHC.Num.Num (Learn.Neural.Layer.CParam Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o])
instance (GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o])) => GHC.Real.Fractional (Learn.Neural.Layer.CParam Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o])
instance GHC.Num.Num (Learn.Neural.Layer.CState Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o])
instance GHC.Real.Fractional (Learn.Neural.Layer.CState Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o])
instance Generics.SOP.Universe.Generic (Learn.Neural.Layer.CParam Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o])
instance (Numeric.BLAS.BLAS b, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o])) => Learn.Neural.Layer.Component Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o]
instance (Numeric.BLAS.BLAS b, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o])) => Learn.Neural.Layer.ComponentFF Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o]
instance (Numeric.BLAS.BLAS b, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o])) => Learn.Neural.Layer.ComponentLayer r Learn.Neural.Layer.FullyConnected.FullyConnected b '[i] '[o]

module Learn.Neural.Layer.Identity
data Ident :: Type
instance GHC.Num.Num (Learn.Neural.Layer.CParam Learn.Neural.Layer.Identity.Ident b i i)
instance GHC.Real.Fractional (Learn.Neural.Layer.CParam Learn.Neural.Layer.Identity.Ident b i i)
instance GHC.Num.Num (Learn.Neural.Layer.CState Learn.Neural.Layer.Identity.Ident b i i)
instance GHC.Real.Fractional (Learn.Neural.Layer.CState Learn.Neural.Layer.Identity.Ident b i i)
instance Numeric.BLAS.BLAS b => Learn.Neural.Layer.Component Learn.Neural.Layer.Identity.Ident b i i
instance Numeric.BLAS.BLAS b => Learn.Neural.Layer.ComponentFF Learn.Neural.Layer.Identity.Ident b i i
instance Numeric.BLAS.BLAS b => Learn.Neural.Layer.ComponentLayer r Learn.Neural.Layer.Identity.Ident b i i

module Learn.Neural.Layer.Mapping
data Mapping :: k -> Type
data CommonMap :: Type
[MF_Ident] :: CommonMap
[MF_Logit] :: CommonMap
[MF_ReLU] :: CommonMap
[MF_ReLUp] :: a -> CommonMap
[MF_ELU] :: CommonMap
[MF_ELUp] :: a -> CommonMap
type IdentMap = Mapping MF_Ident
type LogitMap = Mapping MF_Logit
type ReLUMap = Mapping MF_ReLU
type ReLUpMap s = Mapping (MF_ReLUp s)
type ELUMap = Mapping MF_ELU
type ELUpMap s = Mapping (MF_ELUp s)
newtype MapFunc :: Type
[MF] :: {runMapFunc :: forall a. RealFloat a => a -> a} -> MapFunc
data PMapping :: k -> N -> Type
data CommonPMap :: Type
[PMF_PReLU] :: CommonPMap
[PMF_PELU] :: CommonPMap
type PReLUMap = PMapping PMF_PReLU
type PELUMap = PMapping PMF_PELU
data PMapFunc :: N -> Type
[PMF] :: {runPMapFunc :: forall a. RealFloat a => (I :&: Vec n) a -> a, getPMapDef :: Vec n (SomeC ContGen I)} -> PMapFunc n
instance forall k (s :: k) (n :: Type.Family.Nat.N) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]). GHC.Generics.Generic (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Mapping.PMapping s n) b i i)
instance forall k (s :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]). GHC.Num.Num (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Mapping.Mapping s) b i i)
instance forall k (s :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]). GHC.Real.Fractional (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Mapping.Mapping s) b i i)
instance forall k (s :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]). GHC.Num.Num (Learn.Neural.Layer.CState (Learn.Neural.Layer.Mapping.Mapping s) b i i)
instance forall k (s :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]). GHC.Real.Fractional (Learn.Neural.Layer.CState (Learn.Neural.Layer.Mapping.Mapping s) b i i)
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (i :: [GHC.Types.Nat]). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s Learn.Neural.Layer.Mapping.MapFunc, Data.Singletons.SingI i) => Learn.Neural.Layer.Component (Learn.Neural.Layer.Mapping.Mapping s) b i i
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (i :: [GHC.Types.Nat]). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s Learn.Neural.Layer.Mapping.MapFunc, Data.Singletons.SingI i) => Learn.Neural.Layer.ComponentFF (Learn.Neural.Layer.Mapping.Mapping s) b i i
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (i :: [GHC.Types.Nat]) (r :: Learn.Neural.Layer.RunMode). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s Learn.Neural.Layer.Mapping.MapFunc, Data.Singletons.SingI i) => Learn.Neural.Layer.ComponentLayer r (Learn.Neural.Layer.Mapping.Mapping s) b i i
instance Data.Reflection.Reifies 'Learn.Neural.Layer.Mapping.MF_Ident Learn.Neural.Layer.Mapping.MapFunc
instance Data.Reflection.Reifies 'Learn.Neural.Layer.Mapping.MF_Logit Learn.Neural.Layer.Mapping.MapFunc
instance Data.Reflection.Reifies 'Learn.Neural.Layer.Mapping.MF_ReLU Learn.Neural.Layer.Mapping.MapFunc
instance forall a (s :: a). Data.Reflection.Reifies s GHC.Types.Double => Data.Reflection.Reifies ('Learn.Neural.Layer.Mapping.MF_ReLUp s) Learn.Neural.Layer.Mapping.MapFunc
instance Data.Reflection.Reifies 'Learn.Neural.Layer.Mapping.MF_ELU Learn.Neural.Layer.Mapping.MapFunc
instance forall a (s :: a). Data.Reflection.Reifies s GHC.Types.Double => Data.Reflection.Reifies ('Learn.Neural.Layer.Mapping.MF_ELUp s) Learn.Neural.Layer.Mapping.MapFunc
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (n :: Type.Family.Nat.N) (s :: k) (i :: [GHC.Types.Nat]). (Numeric.Tensor.Tensor b, Type.Class.Known.Known Data.Type.Nat.Nat n) => GHC.Num.Num (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Mapping.PMapping s n) b i i)
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (n :: Type.Family.Nat.N) (s :: k) (i :: [GHC.Types.Nat]). (Numeric.Tensor.Tensor b, Type.Class.Known.Known Data.Type.Nat.Nat n) => GHC.Real.Fractional (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Mapping.PMapping s n) b i i)
instance forall k (s :: k) (n :: Type.Family.Nat.N) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]). GHC.Num.Num (Learn.Neural.Layer.CState (Learn.Neural.Layer.Mapping.PMapping s n) b i i)
instance forall k (s :: k) (n :: Type.Family.Nat.N) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]). GHC.Real.Fractional (Learn.Neural.Layer.CState (Learn.Neural.Layer.Mapping.PMapping s n) b i i)
instance forall k (s :: k) (n :: Type.Family.Nat.N) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: [GHC.Types.Nat]). Generics.SOP.Universe.Generic (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Mapping.PMapping s n) b i i)
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (n :: Type.Family.Nat.N) (i :: [GHC.Types.Nat]). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s (Learn.Neural.Layer.Mapping.PMapFunc n), Data.Singletons.SingI i, Type.Class.Known.Known Data.Type.Nat.Nat n) => Learn.Neural.Layer.Component (Learn.Neural.Layer.Mapping.PMapping s n) b i i
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (n :: Type.Family.Nat.N) (i :: [GHC.Types.Nat]). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s (Learn.Neural.Layer.Mapping.PMapFunc n), Data.Singletons.SingI i, Type.Class.Known.Known Data.Type.Nat.Nat n) => Learn.Neural.Layer.ComponentFF (Learn.Neural.Layer.Mapping.PMapping s n) b i i
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (s :: k) (n :: Type.Family.Nat.N) (i :: [GHC.Types.Nat]) (r :: Learn.Neural.Layer.RunMode). (Numeric.BLAS.BLAS b, Data.Reflection.Reifies s (Learn.Neural.Layer.Mapping.PMapFunc n), Data.Singletons.SingI i, Type.Class.Known.Known Data.Type.Nat.Nat n) => Learn.Neural.Layer.ComponentLayer r (Learn.Neural.Layer.Mapping.PMapping s n) b i i
instance Data.Reflection.Reifies 'Learn.Neural.Layer.Mapping.PMF_PReLU (Learn.Neural.Layer.Mapping.PMapFunc Type.Family.Nat.N1)
instance Data.Reflection.Reifies 'Learn.Neural.Layer.Mapping.PMF_PELU (Learn.Neural.Layer.Mapping.PMapFunc Type.Family.Nat.N1)

module Learn.Neural.Layer.Recurrent.FullyConnected
data FullyConnectedR :: Type
data FullyConnectedR' :: k -> Type
data CommonMap :: Type
[MF_Ident] :: CommonMap
[MF_Logit] :: CommonMap
[MF_ReLU] :: CommonMap
[MF_ReLUp] :: a -> CommonMap
[MF_ELU] :: CommonMap
[MF_ELUp] :: a -> CommonMap
newtype MapFunc :: Type
[MF] :: {runMapFunc :: forall a. RealFloat a => a -> a} -> MapFunc
instance GHC.Generics.Generic (Learn.Neural.Layer.CParam Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR b '[i] '[o])
instance forall k (c :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: GHC.Types.Nat) (o :: GHC.Types.Nat). GHC.Generics.Generic (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR' c) b '[i] '[o])
instance Generics.SOP.Universe.Generic (Learn.Neural.Layer.CParam Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR b '[i] '[o])
instance (GHC.Num.Num (b '[o, o]), GHC.Num.Num (b '[o, i]), GHC.Num.Num (b '[o])) => GHC.Num.Num (Learn.Neural.Layer.CParam Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR b '[i] '[o])
instance (GHC.Real.Fractional (b '[o, o]), GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o])) => GHC.Real.Fractional (Learn.Neural.Layer.CParam Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR b '[i] '[o])
instance GHC.Num.Num (b '[o]) => GHC.Num.Num (Learn.Neural.Layer.CState Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR b '[i] '[o])
instance GHC.Real.Fractional (b '[o]) => GHC.Real.Fractional (Learn.Neural.Layer.CState Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR b '[i] '[o])
instance (Numeric.BLAS.BLAS b, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.Real.Fractional (b '[o]), GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o, o])) => Learn.Neural.Layer.Component Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR b '[i] '[o]
instance (Numeric.BLAS.BLAS b, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.Real.Fractional (b '[o]), GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o, o])) => Learn.Neural.Layer.ComponentLayer 'Learn.Neural.Layer.Recurrent Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR b '[i] '[o]
instance forall k (c :: k) (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: GHC.Types.Nat) (o :: GHC.Types.Nat). Generics.SOP.Universe.Generic (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR' c) b '[i] '[o])
instance forall k (b :: [GHC.Types.Nat] -> *) (o :: GHC.Types.Nat) (i :: GHC.Types.Nat) (s :: k). (GHC.Num.Num (b '[o, o]), GHC.Num.Num (b '[o, i]), GHC.Num.Num (b '[o])) => GHC.Num.Num (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR' s) b '[i] '[o])
instance forall k (b :: [GHC.Types.Nat] -> *) (o :: GHC.Types.Nat) (i :: GHC.Types.Nat) (s :: k). (GHC.Real.Fractional (b '[o, o]), GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o])) => GHC.Real.Fractional (Learn.Neural.Layer.CParam (Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR' s) b '[i] '[o])
instance forall k (b :: [GHC.Types.Nat] -> *) (o :: GHC.Types.Nat) (s :: k) (i :: GHC.Types.Nat). GHC.Num.Num (b '[o]) => GHC.Num.Num (Learn.Neural.Layer.CState (Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR' s) b '[i] '[o])
instance forall k (b :: [GHC.Types.Nat] -> *) (o :: GHC.Types.Nat) (s :: k) (i :: GHC.Types.Nat). GHC.Real.Fractional (b '[o]) => GHC.Real.Fractional (Learn.Neural.Layer.CState (Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR' s) b '[i] '[o])
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: GHC.Types.Nat) (o :: GHC.Types.Nat) (s :: k). (Numeric.BLAS.BLAS b, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.Real.Fractional (b '[o]), GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o, o]), Data.Reflection.Reifies s Learn.Neural.Layer.Mapping.MapFunc) => Learn.Neural.Layer.Component (Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR' s) b '[i] '[o]
instance forall k (b :: [GHC.Types.Nat] -> GHC.Types.Type) (i :: GHC.Types.Nat) (o :: GHC.Types.Nat) (s :: k). (Numeric.BLAS.BLAS b, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, GHC.Real.Fractional (b '[o]), GHC.Real.Fractional (b '[o, i]), GHC.Real.Fractional (b '[o, o]), Data.Reflection.Reifies s Learn.Neural.Layer.Mapping.MapFunc) => Learn.Neural.Layer.ComponentLayer 'Learn.Neural.Layer.Recurrent (Learn.Neural.Layer.Recurrent.FullyConnected.FullyConnectedR' s) b '[i] '[o]

module Learn.Neural.Loss
type LossFunction as b = forall s. Tuple as -> OpB s as '[b]
crossEntropy :: forall b n. (BLAS b, KnownNat n, Num (b '[n])) => LossFunction '[b '[n]] (Scalar b)
squaredError :: (BLAS b, KnownNat n, Num (b '[n])) => LossFunction '[b '[n]] (Scalar b)
sumLoss :: forall n a b. (Num a, Num b) => LossFunction '[a] b -> Nat n -> LossFunction (Replicate n a) b
sumLossDecay :: forall n a b. (Num a, Num b) => LossFunction '[a] b -> Nat n -> b -> LossFunction (Replicate n a) b
zipLoss :: forall n a b. (Num a, Num b) => LossFunction '[a] b -> Vec n b -> LossFunction (Replicate n a) b

module Learn.Neural.Train
data Optimizer :: Type -> Type -> Type
[MkO] :: {oState :: s, oUpdate :: a -> p -> s -> (p, s)} -> Optimizer a p
runOptimizer :: a -> p -> Optimizer a p -> (p, Optimizer a p)
runOptimizer_ :: a -> p -> Optimizer a p -> p
optimizeList :: [a] -> p -> Optimizer a p -> (p, Optimizer a p)
optimizeList_ :: [a] -> p -> Optimizer a p -> p
sgdOptimizer :: forall p as bs c. (Fractional p, Num c, Every Num as, Every Num bs, Known Length as) => Double -> (forall s. OpB s (p : as) bs) -> LossFunction bs c -> Optimizer (Tuple as, Tuple bs) p
sgdMiniBatchOptimizer :: forall f p as bs c. (Foldable f, Fractional p, Num c, Every Num as, Every Num bs, Known Length as) => Double -> (forall s. OpB s (p : as) bs) -> LossFunction bs c -> Optimizer (f (Tuple as, Tuple bs)) p
slidingParts :: Nat n -> [a] -> [Vec n a]
slidingPartsSplit :: Nat n -> [(a, b)] -> [(Vec n a, Vec n b)]
slidingPartsLast :: Nat (S n) -> [(a, b)] -> [(Vec (S n) a, b)]
asFeedback :: [a] -> [(a, a)]

module Learn.Neural.Network
data LChain :: Type
[:~] :: [Nat] -> Type -> LChain
type (:~) s c = s :~ c
data Network :: RunMode -> ([Nat] -> Type) -> LChain -> [LChain] -> [Nat] -> Type
[NetExt] :: (ComponentLayer r c b i o, CConstr c b i o) => Layer r c b i o -> Network r b (i :~ c) '[] o
[:&] :: (ComponentLayer r c b i h, CConstr c b i h, Num (b h)) => Layer r c b i h -> Network r b (h :~ d) hs o -> Network r b (i :~ c) ((h :~ d) : hs) o
netOp :: forall b i c hs o r s. (BLAS b, Num (b i), Num (b o)) => OpB s '[Network r b (i :~ c) hs o, b i] '[Network r b (i :~ c) hs o, b o]
netOpPure :: forall b i c hs o s. (BLAS b, Num (b i), Num (b o)) => OpB s '[Network FeedForward b (i :~ c) hs o, b i] '[b o]
netOpRecurrent :: forall n b i c hs o s. (Known (NetStruct Recurrent b (i :~ c) hs) o, BLAS b, Num (b o), Num (b i)) => Nat n -> OpB s (Network Recurrent b (i :~ c) hs o : Replicate n (b i)) (Network Recurrent b (i :~ c) hs o : Replicate n (b o))
netOpRecurrent_ :: forall n b i c hs o s. (Known (NetStruct Recurrent b (i :~ c) hs) o, BLAS b, Num (b o), Num (b i)) => Nat n -> OpB s (Network Recurrent b (i :~ c) hs o : Replicate n (b i)) (Replicate n (b o))
netOpRecurrentLast :: forall n b i c hs o s. (Known (NetStruct Recurrent b (i :~ c) hs) o, BLAS b, Num (b o), Num (b i)) => Nat n -> OpB s (Network Recurrent b (i :~ c) hs o : (b i : Replicate n (b i))) '[Network Recurrent b (i :~ c) hs o, b o]
netOpRecurrentLast_ :: forall n b i c hs o s. (Known (NetStruct Recurrent b (i :~ c) hs) o, BLAS b, Num (b o), Num (b i)) => Nat n -> OpB s (Network Recurrent b (i :~ c) hs o : (b i : Replicate n (b i))) '[b o]
runNet :: (Num (b i), Num (b o), BLAS b) => Network r b (i :~ c) hs o -> b i -> (b o, Network r b (i :~ c) hs o)
runNetPure :: (Num (b i), Num (b o), BLAS b) => Network FeedForward b (i :~ c) hs o -> b i -> b o
runNetRecurrent :: (Num (b i), Num (b o), BLAS b) => Network Recurrent b (i :~ c) hs o -> [b i] -> ([b o], Network Recurrent b (i :~ c) hs o)
runNetRecurrentLast :: (Num (b i), Num (b o), BLAS b) => Network Recurrent b (i :~ c) hs o -> NonEmpty (b i) -> (b o, Network Recurrent b (i :~ c) hs o)
runNetFeedback :: (Num (b i), Num (b o), BLAS b) => Nat n -> (b o -> b i) -> Network Recurrent b (i :~ c) hs o -> b i -> (VecT n b o, Network Recurrent b (i :~ c) hs o)
runNetFeedbackM :: (Num (b i), Num (b o), BLAS b, Monad m) => Nat n -> (b o -> m (b i)) -> Network Recurrent b (i :~ c) hs o -> b i -> m (VecT n b o, Network Recurrent b (i :~ c) hs o)
runNetFeedbackForever :: (Num (b i), Num (b o), BLAS b) => (b o -> b i) -> Network Recurrent b (i :~ c) hs o -> b i -> [b o]
data NetConf :: RunMode -> ([Nat] -> Type) -> LChain -> [LChain] -> [Nat] -> Type
[NCExt] :: (ComponentLayer r c b i o, CConstr c b i o) => CConf c b i o -> NetConf r b (i :~ c) '[] o
[:&~] :: (ComponentLayer r c b i h, CConstr c b i h, SingI h, Num (b h)) => CConf c b i h -> NetConf r b (h :~ d) hs o -> NetConf r b (i :~ c) ((h :~ d) : hs) o
initNet :: forall b i c hs o m r. (PrimMonad m, BLAS b, SingI i, SingI o) => NetConf r b (i :~ c) hs o -> Gen (PrimState m) -> m (Network r b (i :~ c) hs o)
data NetStruct :: RunMode -> ([Nat] -> Type) -> LChain -> [LChain] -> [Nat] -> Type
[NSExt] :: (ComponentLayer r c b i o, CConstr c b i o) => NetStruct r b (i :~ c) '[] o
[NSInt] :: (SingI h, Num (b h), ComponentLayer r c b i h, CConstr c b i h) => NetStruct r b (h :~ d) hs o -> NetStruct r b (i :~ c) ((h :~ d) : hs) o
defNetConf' :: NetStruct r b i hs o -> NetConf r b i hs o
defNetConf :: Known (NetStruct r b i hs) o => NetConf r b i hs o
initDefNet' :: forall b i c hs o m r. (PrimMonad m, BLAS b, SingI i, SingI o) => NetStruct r b (i :~ c) hs o -> Gen (PrimState m) -> m (Network r b (i :~ c) hs o)
initDefNet :: (PrimMonad m, BLAS b, SingI i, SingI o, Known (NetStruct r b (i :~ c) hs) o) => Gen (PrimState m) -> m (Network r b (i :~ c) hs o)
data SomeNet :: RunMode -> ([Nat] -> Type) -> [Nat] -> [Nat] -> Type
[SomeNet] :: NetStruct r b (i :~ c) hs o -> Network r b (i :~ c) hs o -> SomeNet r b i o
someNet :: Known (NetStruct r b (i :~ c) hs) o => Network r b (i :~ c) hs o -> SomeNet r b i o
instance (Learn.Neural.Layer.ComponentLayer r c b i o, Learn.Neural.Layer.CConstr c b i o) => Type.Class.Known.Known (Learn.Neural.Network.NetStruct r b (i Learn.Neural.Network.:~ c) '[]) o
instance (Data.Singletons.SingI h, GHC.Num.Num (b h), Learn.Neural.Layer.ComponentLayer r c b i h, Learn.Neural.Layer.CConstr c b i h, Type.Class.Known.Known (Learn.Neural.Network.NetStruct r b (h Learn.Neural.Network.:~ d) hs) o) => Type.Class.Known.Known (Learn.Neural.Network.NetStruct r b (i Learn.Neural.Network.:~ c) (h Learn.Neural.Network.:~ d : hs)) o
instance Type.Class.Known.Known (Learn.Neural.Network.NetStruct r b (i Learn.Neural.Network.:~ c) hs) o => GHC.Num.Num (Learn.Neural.Network.Network r b (i Learn.Neural.Network.:~ c) hs o)
instance Type.Class.Known.Known (Learn.Neural.Network.NetStruct r b (i Learn.Neural.Network.:~ c) hs) o => GHC.Real.Fractional (Learn.Neural.Network.Network r b (i Learn.Neural.Network.:~ c) hs o)

module Learn.Neural.Test
type TestFunc o = forall b. (BLAS b, Num (b o)) => b o -> b o -> Double
maxTest :: KnownNat n => TestFunc '[n]
rmseTest :: KnownNat n => TestFunc '[n]
testNet :: (BLAS b, Num (b i), Num (b o)) => TestFunc o -> SomeNet FeedForward b i o -> b i -> b o -> Double
testNetList :: (BLAS b, Num (b i), Num (b o)) => TestFunc o -> SomeNet FeedForward b i o -> [(b i, b o)] -> Double

module Learn.Neural

module Numeric.BLAS.HMatrix
newtype HM :: [Nat] -> Type
[HM] :: {getHM :: HM' b} -> HM b
flatten :: SingI s => HM s -> Vector (Product s) Double
unflatten :: Sing s -> Vector (Product s) Double -> HM s
instance GHC.Generics.Generic (Numeric.BLAS.HMatrix.HM a)
instance Control.DeepSeq.NFData (Numeric.BLAS.HMatrix.HM' s) => Control.DeepSeq.NFData (Numeric.BLAS.HMatrix.HM s)
instance GHC.Show.Show (Numeric.BLAS.HMatrix.HM' s) => GHC.Show.Show (Numeric.BLAS.HMatrix.HM s)
instance GHC.Num.Num (Numeric.BLAS.HMatrix.HM' s) => GHC.Num.Num (Numeric.BLAS.HMatrix.HM s)
instance GHC.Real.Fractional (Numeric.BLAS.HMatrix.HM' s) => GHC.Real.Fractional (Numeric.BLAS.HMatrix.HM s)
instance Numeric.BLAS.BLAS Numeric.BLAS.HMatrix.HM
instance Numeric.Tensor.Tensor Numeric.BLAS.HMatrix.HM
instance Data.Singletons.SingI s => Data.MonoTraversable.MonoFunctor (Numeric.BLAS.HMatrix.HM s)
instance Data.Singletons.SingI s => Data.MonoTraversable.MonoFoldable (Numeric.BLAS.HMatrix.HM s)
