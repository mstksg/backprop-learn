<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DeriveGeneric             #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE ExistentialQuantification #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances         #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE InstanceSigs              #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase                #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses     #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE PartialTypeSignatures     #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables       #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications          #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies              #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE TypeInType                #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE UndecidableInstances      #-}</span><span>
</span><a name="line-13"></a><span>
</span><a name="line-14"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Learn</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">Layer</span><span class="hs-operator">.</span><span class="hs-identifier">Recurrent</span><span class="hs-operator">.</span><span class="hs-identifier">LSTM</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-15"></a><span>  </span><a href="Learn.Neural.Layer.Recurrent.LSTM.html#LSTM"><span class="hs-identifier hs-type">LSTM</span></a><span>
</span><a name="line-16"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-17"></a><span>
</span><a name="line-18"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Kind</span><span>
</span><a name="line-19"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">Prelude</span><span>
</span><a name="line-20"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span>                   </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-21"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">Numeric</span><span>
</span><a name="line-22"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>
</span><a name="line-23"></a><span class="hs-keyword">import</span><span>           </span><a href="Learn.Neural.Layer.html"><span class="hs-identifier">Learn</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">Layer</span></a><span>
</span><a name="line-24"></a><span class="hs-keyword">import</span><span>           </span><a href="Numeric.BLAS.html"><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">BLAS</span></a><span>
</span><a name="line-25"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Backprop</span><span>
</span><a name="line-26"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Backprop</span><span class="hs-operator">.</span><span class="hs-identifier">Iso</span><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Statistics</span><span class="hs-operator">.</span><span class="hs-identifier">Distribution</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Statistics</span><span class="hs-operator">.</span><span class="hs-identifier">Distribution</span><span class="hs-operator">.</span><span class="hs-identifier">Normal</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span>                   </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">SOP</span><span>
</span><a name="line-30"></a><span>
</span><a name="line-31"></a><span class="hs-keyword">data</span><span> </span><a name="LSTM"><a href="Learn.Neural.Layer.Recurrent.LSTM.html#LSTM"><span class="hs-identifier">LSTM</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-32"></a><span>
</span><a name="line-33"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><span> </span><a href="Numeric.BLAS.html#BLAS"><span class="hs-identifier hs-type">BLAS</span></a><span> </span><a href="#local-6989586621679382826"><span class="hs-identifier hs-type">b</span></a><span>
</span><a name="line-34"></a><span>         </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">KnownNat</span><span> </span><a href="#local-6989586621679382827"><span class="hs-identifier hs-type">i</span></a><span>
</span><a name="line-35"></a><span>         </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">KnownNat</span><span> </span><a href="#local-6989586621679382828"><span class="hs-identifier hs-type">o</span></a><span>
</span><a name="line-36"></a><span>         </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Floating</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679382826"><span class="hs-identifier hs-type">b</span></a><span> </span><span class="hs-char">'[o])
         , Floating (b '[o,i])
         , Floating (b '[o,o])
         )
        =&gt; Component LSTM b '[i] '[o] where

    data CParam LSTM b '[i] '[o] =
        LP { _lpForgetInp     :: !(b '[o,i])
           , _lpForgetState   :: !(b '[o,o])
           , _lpForgetBias    :: !(b '[o])
           , _lpRememberInp   :: !(b '[o,i])
           , _lpRememberState :: !(b '[o,o])
           , _lpRememberBias  :: !(b '[o])
           , _lpCommitInp     :: !(b '[o,i])
           , _lpCommitState   :: !(b '[o,o])
           , _lpCommitBias    :: !(b '[o])
           , _lpOutInp        :: !(b '[o,i])
           , _lpOutState      :: !(b '[o,o])
           , _lpOutBias       :: !(b '[o])
           }
      deriving (Generic)
    data CState LSTM b '[i] '[o] =
        LS { _lsCellState   :: !(b '[o])
           , _lsHiddenState :: !(b '[o])
           }
      deriving (Generic)
    type CConstr LSTM b '[i] '[o] = (Num (b '[o,i]), Num (b '[o,o]), Num (b '[o]))
    data CConf   LSTM b '[i] '[o] = forall d. ContGen d =&gt; LC d

    componentOp :: forall s. (Num (b '[i]), Num (b '[o]), CConstr LSTM b '[i] '[o])
        =&gt; OpB s '[b '[i], CParam LSTM b '[i] '[o], CState LSTM b '[i] '[o]] '[b '[o], CState LSTM b '[i] '[o]]
    componentOp = bpOp . withInps $ \(x :&lt; p :&lt; s :&lt; &#216;) -&gt; do
        fI :&lt; fS :&lt; fB :&lt; rI :&lt; rS :&lt; rB :&lt; cI :&lt; cS :&lt; cB :&lt; oI :&lt; oS :&lt; oB :&lt; &#216; &lt;- gTuple #&lt;~ p
        sC :&lt; sH :&lt; &#216; &lt;- gTuple #&lt;~ s
        let forget   = sum [ matVecOp .$ (fI :&lt; x  :&lt; &#216;)
                           , matVecOp .$ (fS :&lt; sH :&lt; &#216;)
                           , fB
                           ]
            remember = sum [ matVecOp .$ (rI :&lt; x  :&lt; &#216;)
                           , matVecOp .$ (rS :&lt; sH :&lt; &#216;)
                           , rB
                           ]
            commit   = sum [ matVecOp .$ (cI :&lt; x  :&lt; &#216;)
                           , matVecOp .$ (cS :&lt; sH :&lt; &#216;)
                           , cB
                           ]
            out      = sum [ matVecOp .$ (oI :&lt; x  :&lt; &#216;)
                           , matVecOp .$ (oS :&lt; sH :&lt; &#216;)
                           , oB
                           ]
        forget'   &lt;- tmapOp logistic ~$ (forget   :&lt; &#216;)
        remember' &lt;- tmapOp logistic ~$ (remember :&lt; &#216;)
        commit'   &lt;- tmapOp tanh     ~$ (commit   :&lt; &#216;)
        out'      &lt;- tmapOp logistic ~$ (out      :&lt; &#216;)
        sC'       &lt;- tmapOp tanh ~$ ((forget' * sC + remember' * commit') :&lt; &#216;)
        finalOut  &lt;- bindVar $ out' * sC'
        s' :&lt; &#216;   &lt;- isoVar (from (gTuple @(CState LSTM b '[i] '[o])) . tup1)
                            (sC' :&lt; finalOut :&lt; &#216;)
        return $ finalOut :&lt; s' :&lt; &#216;
      where
        logistic :: Floating a =&gt; a -&gt; a
        logistic x = 1 / (1 + exp (-x))

    defConf = LC (normalDistr 0 0.5)
    initParam = \case
      i `SCons` SNil -&gt; \case
        so@(o `SCons` SNil) -&gt; \(LC d) g -&gt; do
          LP &lt;$&gt; genA (o `SCons` (i `SCons` SNil)) (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA (o `SCons` (o `SCons` SNil)) (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA so                           (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA (o `SCons` (i `SCons` SNil)) (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA (o `SCons` (o `SCons` SNil)) (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA so                           (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA (o `SCons` (i `SCons` SNil)) (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA (o `SCons` (o `SCons` SNil)) (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA so                           (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA (o `SCons` (i `SCons` SNil)) (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA (o `SCons` (o `SCons` SNil)) (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
             &lt;*&gt; genA so                           (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
        _ -&gt; error &quot;inaccessible&quot;
      _ -&gt; error &quot;inaccessible&quot;
    initState _ so (LC d) g =
        LS &lt;$&gt; genA so (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)
           &lt;*&gt; genA so (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)

instance ( BLAS b
         , KnownNat i
         , KnownNat o
         , Floating (b '[o])
         , Floating (b '[o,i])
         , Floating (b '[o,o])
         )
      =&gt; ComponentLayer 'Recurrent LSTM b '[i] '[o] where
    componentRunMode = RMNotFF

instance SOP.Generic (CState LSTM b '[i] '[o])
instance SOP.Generic (CParam LSTM b '[i] '[o])

instance (Num (b '[o,i]), Num (b '[o,o]), Num (b '[o])) =&gt; Num (CParam LSTM b '[i] '[o]) where
    (+)         = genericPlus
    (-)         = genericMinus
    (*)         = genericTimes
    negate      = genericNegate
    abs         = genericAbs
    signum      = genericSignum
    fromInteger = genericFromInteger

instance (Fractional (b '[o,i]), Fractional (b '[o,o]), Fractional (b '[o])) =&gt; Fractional (CParam LSTM b '[i] '[o]) where
    (/)          = genericDivide
    recip        = genericRecip
    fromRational = genericFromRational

instance (Floating (b '[o,i]), Floating (b '[o,o]), Floating (b '[o])) =&gt; Floating (CParam LSTM b '[i] '[o]) where
    pi      = genericPi
    exp     = genericExp
    (**)    = genericPower
    log     = genericLog
    logBase = genericLogBase
    sin     = genericSin
    cos     = genericCos
    tan     = genericTan
    asin    = genericAsin
    acos    = genericAcos
    atan    = genericAtan
    sinh    = genericSinh
    cosh    = genericCosh
    tanh    = genericTanh
    asinh   = genericAsinh
    acosh   = genericAcosh
    atanh   = genericAtanh

instance (Num (b '[o,i]), Num (b '[o,o]), Num (b '[o])) =&gt; Num (CState LSTM b '[i] '[o]) where
    (+)         = genericPlus
    (-)         = genericMinus
    (*)         = genericTimes
    negate      = genericNegate
    abs         = genericAbs
    signum      = genericSignum
    fromInteger = genericFromInteger

instance (Fractional (b '[o,i]), Fractional (b '[o,o]), Fractional (b '[o])) =&gt; Fractional (CState LSTM b '[i] '[o]) where
    (/)          = genericDivide
    recip        = genericRecip
    fromRational = genericFromRational

instance (Floating (b '[o,i]), Floating (b '[o,o]), Floating (b '[o])) =&gt; Floating (CState LSTM b '[i] '[o]) where
    pi      = genericPi
    exp     = genericExp
    (**)    = genericPower
    log     = genericLog
    logBase = genericLogBase
    sin     = genericSin
    cos     = genericCos
    tan     = genericTan
    asin    = genericAsin
    acos    = genericAcos
    atan    = genericAtan
    sinh    = genericSinh
    cosh    = genericCosh
    tanh    = genericTanh
    asinh   = genericAsinh
    acosh   = genericAcosh
    atanh   = genericAtanh

</span></pre></body></html>