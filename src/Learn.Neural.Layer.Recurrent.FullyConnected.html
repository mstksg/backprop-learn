<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DataKinds                 #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DeriveGeneric             #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE ExistentialQuantification #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts          #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances         #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE GADTs                     #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase                #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses     #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables       #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving        #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications          #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies              #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE TypeInType                #-}</span><span>
</span><a name="line-14"></a><span class="hs-pragma">{-# LANGUAGE TypeSynonymInstances      #-}</span><span>
</span><a name="line-15"></a><span class="hs-pragma">{-# LANGUAGE UndecidableInstances      #-}</span><span>
</span><a name="line-16"></a><span>
</span><a name="line-17"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Learn</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">Layer</span><span class="hs-operator">.</span><span class="hs-identifier">Recurrent</span><span class="hs-operator">.</span><span class="hs-identifier">FullyConnected</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-18"></a><span>    </span><a href="Learn.Neural.Layer.Recurrent.FullyConnected.html#FullyConnectedR"><span class="hs-identifier hs-type">FullyConnectedR</span></a><span>
</span><a name="line-19"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Learn.Neural.Layer.Recurrent.FullyConnected.html#FullyConnectedR%27"><span class="hs-identifier hs-type">FullyConnectedR'</span></a><span>
</span><a name="line-20"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Learn.Neural.Layer.Mapping.html#CommonMap"><span class="hs-identifier hs-type">CommonMap</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-21"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Learn.Neural.Layer.Mapping.html#MapFunc"><span class="hs-identifier hs-type">MapFunc</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-22"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-23"></a><span>
</span><a name="line-24"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Kind</span><span>
</span><a name="line-25"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Proxy</span><span>
</span><a name="line-26"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Reflection</span><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">Prelude</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span>                   </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span>           </span><a href="Learn.Neural.Layer.html"><span class="hs-identifier">Learn</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">Layer</span></a><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span>           </span><a href="Learn.Neural.Layer.Mapping.html"><span class="hs-identifier">Learn</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">Layer</span><span class="hs-operator">.</span><span class="hs-identifier">Mapping</span></a><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span>           </span><a href="Numeric.BLAS.html"><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">BLAS</span></a><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Backprop</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Backprop</span><span class="hs-operator">.</span><span class="hs-identifier">Iso</span><span>           </span><span class="hs-special">(</span><span class="hs-identifier hs-var">iso</span><span class="hs-special">)</span><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Backprop</span><span class="hs-operator">.</span><span class="hs-identifier">Op</span><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Statistics</span><span class="hs-operator">.</span><span class="hs-identifier">Distribution</span><span>
</span><a name="line-37"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Statistics</span><span class="hs-operator">.</span><span class="hs-identifier">Distribution</span><span class="hs-operator">.</span><span class="hs-identifier">Normal</span><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Generics</span><span class="hs-operator">.</span><span class="hs-identifier">SOP</span><span>                   </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">SOP</span><span>
</span><a name="line-39"></a><span>
</span><a name="line-40"></a><span class="hs-keyword">data</span><span> </span><a name="FullyConnectedR"><a href="Learn.Neural.Layer.Recurrent.FullyConnected.html#FullyConnectedR"><span class="hs-identifier">FullyConnectedR</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span>
</span><a name="line-41"></a><span>
</span><a name="line-42"></a><span class="hs-keyword">deriving</span><span> </span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier hs-type">Generic</span><span> </span><span class="hs-special">(</span><a href="Learn.Neural.Layer.html#CParam"><span class="hs-identifier hs-type">CParam</span></a><span> </span><a href="Learn.Neural.Layer.Recurrent.FullyConnected.html#FullyConnectedR"><span class="hs-identifier hs-type">FullyConnectedR</span></a><span> </span><a href="#local-6989586621679338578"><span class="hs-identifier hs-type">b</span></a><span> </span><span class="hs-char">'[i] '[o])
instance SOP.Generic (CParam FullyConnectedR b '[i] '[o])

instance (Num (b '[o,o]), Num (b '[o,i]), Num (b '[o]))
      =&gt; Num (CParam FullyConnectedR b '[i] '[o]) where
    FCRP wI1 wS1 b1 + FCRP wI2 wS2 b2 = FCRP (wI1 + wI2) (wS1 + wS2) (b1 + b2)
    FCRP wI1 wS1 b1 - FCRP wI2 wS2 b2 = FCRP (wI1 - wI2) (wS1 - wS2) (b1 - b2)
    FCRP wI1 wS1 b1 * FCRP wI2 wS2 b2 = FCRP (wI1 * wI2) (wS1 * wS2) (b1 * b2)
    negate (FCRP wI wS b) = FCRP (negate wI) (negate wS) (negate b)
    signum (FCRP wI wS b) = FCRP (signum wI) (signum wS) (signum b)
    abs    (FCRP wI wS b) = FCRP (abs    wI) (abs    wS) (abs    b)
    fromInteger x = FCRP (fromInteger x) (fromInteger x) (fromInteger x)

instance (Fractional (b '[o,o]), Fractional (b '[o,i]), Fractional (b '[o]))
      =&gt; Fractional (CParam FullyConnectedR b '[i] '[o]) where
    FCRP wI1 wS1 b1 / FCRP wI2 wS2 b2 = FCRP (wI1 / wI2) (wS1 / wS2) (b1 / b2)
    recip (FCRP wI wS b) = FCRP (recip wI) (recip wS) (recip b)
    fromRational x       = FCRP (fromRational x) (fromRational x) (fromRational x)

instance (Floating (b '[o,o]), Floating (b '[o,i]), Floating (b '[o]))
      =&gt; Floating (CParam FullyConnectedR b '[i] '[o]) where
    sqrt (FCRP wI wS b) = FCRP (sqrt wI) (sqrt wS) (sqrt b)

instance Num (b '[o]) =&gt; Num (CState FullyConnectedR b '[i] '[o]) where
    FCRS s1 + FCRS s2 = FCRS (s1 + s2)
    FCRS s1 - FCRS s2 = FCRS (s1 - s2)
    FCRS s1 * FCRS s2 = FCRS (s1 * s2)
    negate (FCRS s) = FCRS (negate s)
    signum (FCRS s) = FCRS (signum s)
    abs    (FCRS s) = FCRS (abs    s)
    fromInteger x  = FCRS (fromInteger x)

instance Fractional (b '[o]) =&gt; Fractional (CState FullyConnectedR b '[i] '[o]) where
    FCRS s1 / FCRS s2 = FCRS (s1 / s2)
    recip (FCRS s)    = FCRS (recip s)
    fromRational x    = FCRS (fromRational x)

instance Floating (b '[o]) =&gt; Floating (CState FullyConnectedR b '[i] '[o]) where
    sqrt (FCRS s)    = FCRS (sqrt s)

instance ( BLAS b
         , KnownNat i
         , KnownNat o
         , Floating (b '[o])
         , Floating (b '[o,i])
         , Floating (b '[o,o])
         )
        =&gt; Component FullyConnectedR b '[i] '[o] where
    data CParam  FullyConnectedR b '[i] '[o] =
            FCRP { _fcrInpWeights   :: !(b '[o,i])
                 , _fcrStateWeights :: !(b '[o,o])
                 , _fcrBiases       :: !(b '[o])
                 }
    data CState  FullyConnectedR b '[i] '[o] = FCRS { _fcrState :: !(b '[o]) }
    type CConstr FullyConnectedR b '[i] '[o] = (Num (b '[o,i]), Num (b '[o,o]))
    data CConf   FullyConnectedR b '[i] '[o] = forall d. ContGen d =&gt; FCRC d

    componentOp = bpOp . withInps $ \(x :&lt; p :&lt; s :&lt; &#216;) -&gt; do
        wI :&lt; wS :&lt; b :&lt; &#216; &lt;- gTuple #&lt;~ p
        s0 &lt;- opIso (iso _fcrState FCRS) ~$ (s :&lt; &#216;)
        y  &lt;- matVecOp ~$ (wI :&lt; x  :&lt; &#216;)
        s1 &lt;- matVecOp ~$ (wS :&lt; s0 :&lt; &#216;)
        let z = y + s1 + b
        s' &lt;- opIso (iso FCRS _fcrState) ~$ (s1 :&lt; &#216;)
        return $ z :&lt; s' :&lt; &#216;

    defConf = FCRC (normalDistr 0 0.5)
    initParam = \case
      i `SCons` SNil -&gt; \case
        so@(o `SCons` SNil) -&gt; \(FCRC d) g -&gt; do
          wI &lt;- genA (o `SCons` (i `SCons` SNil)) $ \_ -&gt;
            realToFrac &lt;$&gt; genContVar d g
          wS &lt;- genA (o `SCons` (o `SCons` SNil)) $ \_ -&gt;
            realToFrac &lt;$&gt; genContVar d g
          b &lt;- genA so $ \_ -&gt;
            realToFrac &lt;$&gt; genContVar d g
          return $ FCRP wI wS b
        _ -&gt; error &quot;inaccessible&quot;
      _ -&gt; error &quot;inaccessible&quot;
    initState _ so (FCRC d) g =
        FCRS &lt;$&gt; genA so (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)

instance ( BLAS b
         , KnownNat i
         , KnownNat o
         , Floating (b '[o])
         , Floating (b '[o,i])
         , Floating (b '[o,o])
         )
        =&gt; ComponentLayer 'Recurrent FullyConnectedR b '[i] '[o] where
    componentRunMode = RMNotFF

data FullyConnectedR' :: k -&gt; Type

deriving instance Generic (CParam (FullyConnectedR' c) b '[i] '[o])
instance SOP.Generic (CParam (FullyConnectedR' c) b '[i] '[o])

instance (Num (b '[o,o]), Num (b '[o,i]), Num (b '[o]))
      =&gt; Num (CParam (FullyConnectedR' s) b '[i] '[o]) where
    FCRP' wI1 wS1 b1 + FCRP' wI2 wS2 b2 = FCRP' (wI1 + wI2) (wS1 + wS2) (b1 + b2)
    FCRP' wI1 wS1 b1 - FCRP' wI2 wS2 b2 = FCRP' (wI1 - wI2) (wS1 - wS2) (b1 - b2)
    FCRP' wI1 wS1 b1 * FCRP' wI2 wS2 b2 = FCRP' (wI1 * wI2) (wS1 * wS2) (b1 * b2)
    negate (FCRP' wI wS b) = FCRP' (negate wI) (negate wS) (negate b)
    signum (FCRP' wI wS b) = FCRP' (signum wI) (signum wS) (signum b)
    abs    (FCRP' wI wS b) = FCRP' (abs    wI) (abs    wS) (abs    b)
    fromInteger x = FCRP' (fromInteger x) (fromInteger x) (fromInteger x)

instance (Fractional (b '[o,o]), Fractional (b '[o,i]), Fractional (b '[o]))
      =&gt; Fractional (CParam (FullyConnectedR' s) b '[i] '[o]) where
    FCRP' wI1 wS1 b1 / FCRP' wI2 wS2 b2 = FCRP' (wI1 / wI2) (wS1 / wS2) (b1 / b2)
    recip (FCRP' wI wS b) = FCRP' (recip wI) (recip wS) (recip b)
    fromRational x        = FCRP' (fromRational x) (fromRational x) (fromRational x)

instance (Floating (b '[o,o]), Floating (b '[o,i]), Floating (b '[o]))
      =&gt; Floating (CParam (FullyConnectedR' s) b '[i] '[o]) where
    sqrt (FCRP' wI wS b) = FCRP' (sqrt wI) (sqrt wS) (sqrt b)

instance Num (b '[o]) =&gt; Num (CState (FullyConnectedR' s) b '[i] '[o]) where
    FCRS' s1 + FCRS' s2 = FCRS' (s1 + s2)
    FCRS' s1 - FCRS' s2 = FCRS' (s1 - s2)
    FCRS' s1 * FCRS' s2 = FCRS' (s1 * s2)
    negate (FCRS' s) = FCRS' (negate s)
    signum (FCRS' s) = FCRS' (signum s)
    abs    (FCRS' s) = FCRS' (abs    s)
    fromInteger x  = FCRS' (fromInteger x)

instance Fractional (b '[o]) =&gt; Fractional (CState (FullyConnectedR' s) b '[i] '[o]) where
    FCRS' s1 / FCRS' s2 = FCRS' (s1 / s2)
    recip (FCRS' s)     = FCRS' (recip s)
    fromRational x      = FCRS' (fromRational x)

instance Floating (b '[o]) =&gt; Floating (CState (FullyConnectedR' s) b '[i] '[o]) where
    sqrt (FCRS' s)     = FCRS' (sqrt s)


instance ( BLAS b
         , KnownNat i
         , KnownNat o
         , Floating (b '[o])
         , Floating (b '[o,i])
         , Floating (b '[o,o])
         , Reifies s MapFunc
         )
      =&gt; Component (FullyConnectedR' s) b '[i] '[o] where
    data CParam  (FullyConnectedR' c) b '[i] '[o] =
            FCRP' { _fcrInpWeights'   :: !(b '[o,i])
                  , _fcrStateWeights' :: !(b '[o,o])
                  , _fcrBiases'       :: !(b '[o])
                  }
    data CState  (FullyConnectedR' c) b '[i] '[o] = FCRS' { _fcrState' :: !(b '[o]) }
    type CConstr (FullyConnectedR' c) b '[i] '[o] =
      ( Num (b '[o,i])
      , Num (b '[o,o])
      )
    data CConf   (FullyConnectedR' c) b '[i] '[o] = forall d. ContGen d =&gt; FCRC' d

    componentOp = bpOp . withInps $ \(x :&lt; p :&lt; s :&lt; &#216;) -&gt; do
        wI :&lt; wS :&lt; b :&lt; &#216; &lt;- gTuple #&lt;~ p
        s0 &lt;- opIso (iso _fcrState' FCRS') ~$ (s :&lt; &#216;)
        y  &lt;- matVecOp ~$ (wI :&lt; x  :&lt; &#216;)
        s1 &lt;- matVecOp ~$ (wS :&lt; s0 :&lt; &#216;)
        s2 &lt;- tmapOp (runMapFunc mf) ~$ (s1 :&lt; &#216;)
        let z = y + s2 + b
        s' &lt;- opIso (iso FCRS' _fcrState') ~$ (s2 :&lt; &#216;)
        return $ z :&lt; s' :&lt; &#216;
      where
        mf :: MapFunc
        mf = reflect (Proxy @s)

    defConf = FCRC' (normalDistr 0 0.5)

    initParam = \case
      i `SCons` SNil -&gt; \case
        so@(o `SCons` SNil) -&gt; \(FCRC' d) g -&gt; do
          wI &lt;- genA (o `SCons` (i `SCons` SNil)) $ \_ -&gt;
            realToFrac &lt;$&gt; genContVar d g
          wS &lt;- genA (o `SCons` (o `SCons` SNil)) $ \_ -&gt;
            realToFrac &lt;$&gt; genContVar d g
          b &lt;- genA so $ \_ -&gt;
            realToFrac &lt;$&gt; genContVar d g
          return $ FCRP' wI wS b
        _ -&gt; error &quot;inaccessible&quot;
      _ -&gt; error &quot;inaccessible&quot;

    initState _ so (FCRC' d) g =
        FCRS' &lt;$&gt; genA so (\_ -&gt; realToFrac &lt;$&gt; genContVar d g)

instance ( BLAS b
         , KnownNat i
         , KnownNat o
         , Floating (b '[o])
         , Floating (b '[o,i])
         , Floating (b '[o,o])
         , Reifies s MapFunc
         )
      =&gt; ComponentLayer 'Recurrent (FullyConnectedR' s) b '[i] '[o] where
    componentRunMode = RMNotFF

</span></pre></body></html>