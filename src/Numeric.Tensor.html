<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE FlexibleContexts      #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances     #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE GADTs                 #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase            #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE PolyKinds             #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes            #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables   #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications      #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies          #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE TypeInType            #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators         #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE UndecidableInstances  #-}</span><span>
</span><a name="line-14"></a><span>
</span><a name="line-15"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Tensor</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-16"></a><span>    </span><a href="Numeric.Tensor.html#Tensor"><span class="hs-identifier hs-type">Tensor</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-17"></a><span>  </span><span class="hs-comment">-- , DoubleProd(..)</span><span>
</span><a name="line-18"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#ProdMap"><span class="hs-identifier hs-type">ProdMap</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-19"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#Slice"><span class="hs-identifier hs-type">Slice</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-20"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#Conv"><span class="hs-identifier hs-type">Conv</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-21"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#Product"><span class="hs-identifier hs-type">Product</span></a><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#sProduct"><span class="hs-identifier hs-var">sProduct</span></a><span>
</span><a name="line-22"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#fromScalar"><span class="hs-identifier hs-var">fromScalar</span></a><span>
</span><a name="line-23"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#toScalar"><span class="hs-identifier hs-var">toScalar</span></a><span>
</span><a name="line-24"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#fromList%27"><span class="hs-identifier hs-var">fromList'</span></a><span>
</span><a name="line-25"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#fromList"><span class="hs-identifier hs-var">fromList</span></a><span>
</span><a name="line-26"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#convert"><span class="hs-identifier hs-var">convert</span></a><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#convert%27"><span class="hs-identifier hs-var">convert'</span></a><span>
</span><a name="line-27"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#tlist"><span class="hs-identifier hs-var">tlist</span></a><span>
</span><a name="line-28"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#tmapOp"><span class="hs-identifier hs-var">tmapOp</span></a><span>
</span><a name="line-29"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#tzipOp"><span class="hs-identifier hs-var">tzipOp</span></a><span>
</span><a name="line-30"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#tzipNOp"><span class="hs-identifier hs-var">tzipNOp</span></a><span>
</span><a name="line-31"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#tkonstOp"><span class="hs-identifier hs-var">tkonstOp</span></a><span>
</span><a name="line-32"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#tsumOp"><span class="hs-identifier hs-var">tsumOp</span></a><span>
</span><a name="line-33"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#scaleOp"><span class="hs-identifier hs-var">scaleOp</span></a><span>
</span><a name="line-34"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.Tensor.html#oneHot"><span class="hs-identifier hs-var">oneHot</span></a><span>
</span><a name="line-35"></a><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Finite</span><span>
</span><a name="line-36"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-37"></a><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">Trans</span><span class="hs-operator">.</span><span class="hs-identifier">State</span><span class="hs-operator">.</span><span class="hs-identifier">Strict</span><span>
</span><a name="line-39"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Finite</span><span>
</span><a name="line-40"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Foldable</span><span>
</span><a name="line-41"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Kind</span><span>
</span><a name="line-42"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>
</span><a name="line-43"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span>
</span><a name="line-44"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Reflection</span><span>
</span><a name="line-45"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">Prelude</span><span> </span><span class="hs-keyword">hiding</span><span>   </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Reverse</span><span class="hs-special">)</span><span>
</span><a name="line-46"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>
</span><a name="line-47"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Combinator</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>  </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-48"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Type.Util.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Util</span></a><span>
</span><a name="line-49"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span> </span><span class="hs-keyword">hiding</span><span>          </span><span class="hs-special">(</span><span class="hs-identifier hs-var">head'</span><span class="hs-special">)</span><span>
</span><a name="line-50"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>                     </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TL</span><span>
</span><a name="line-51"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">AD</span><span> </span><span class="hs-keyword">hiding</span><span>                </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Scalar</span><span class="hs-special">)</span><span>
</span><a name="line-52"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">AD</span><span class="hs-operator">.</span><span class="hs-identifier">Internal</span><span class="hs-operator">.</span><span class="hs-identifier">Reverse</span><span>
</span><a name="line-53"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">AD</span><span class="hs-operator">.</span><span class="hs-identifier">Mode</span><span class="hs-operator">.</span><span class="hs-identifier">Forward</span><span>          </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Forward</span><span class="hs-special">)</span><span>
</span><a name="line-54"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Backprop</span><span class="hs-operator">.</span><span class="hs-identifier">Op</span><span>
</span><a name="line-55"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Higher</span><span>
</span><a name="line-56"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span class="hs-operator">.</span><span class="hs-identifier">Known</span><span>
</span><a name="line-57"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span> </span><span class="hs-keyword">hiding</span><span>          </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Reverse</span><span class="hs-special">)</span><span>
</span><a name="line-58"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>                  </span><span class="hs-special">(</span><span class="hs-identifier hs-type">N2</span><span class="hs-special">)</span><span>
</span><a name="line-59"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Nat</span><span>                    </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TCN</span><span>
</span><a name="line-60"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Sized</span><span>                </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">V</span><span>
</span><a name="line-61"></a><span>
</span><a name="line-62"></a><span class="hs-keyword">data</span><span> </span><a name="ProdMap"><a href="Numeric.Tensor.html#ProdMap"><span class="hs-identifier">ProdMap</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679157605"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679157606"><span class="hs-identifier hs-type">b</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679157605"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><a href="#local-6989586621679157606"><span class="hs-identifier hs-type">b</span></a><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Type</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-63"></a><span>    </span><a name="PMZ"><a href="Numeric.Tensor.html#PMZ"><span class="hs-identifier">PMZ</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><a href="Numeric.Tensor.html#ProdMap"><span class="hs-identifier hs-type">ProdMap</span></a><span> </span><a href="#local-6989586621679157607"><span class="hs-identifier hs-type">f</span></a><span> </span><span class="hs-char">'[] '[]
    PMS :: f a b -&gt; ProdMap f as bs -&gt; ProdMap f (a ': as) (b ': bs)

data Slice :: Nat -&gt; Nat -&gt; Type where
    Slice :: Sing l -&gt; Sing c -&gt; Sing r -&gt; Slice (l + c + r) c

data Conv :: Nat -&gt; Nat -&gt; Type where
    Conv :: { convMaskDim  :: Sing m
            , convImageDim :: Sing s
            , convStride   :: Finite s
            , convOffset   :: Finite s
            }
         -&gt; Conv m s

class RealFloat (Scalar t)
        =&gt; Tensor (t :: [Nat] -&gt; Type) where
    -- type IndexT t :: k -&gt; Type
    type Scalar t :: Type

    genA
        :: forall f s. Applicative f
        =&gt; Sing s
        -&gt; (Prod Finite s -&gt; f (Scalar t))
        -&gt; f (t s)

    gen :: forall s. Sing s
        -&gt; (Prod Finite s -&gt; Scalar t)
        -&gt; t s
    gen s f = getI $ genA s (I . f)

    tkonst :: Sing s -&gt; Scalar t -&gt; t s
    tkonst s x = gen s $ \_ -&gt; x

    tsum :: SingI s =&gt; t s -&gt; Scalar t
    tmap :: SingI s =&gt; (Scalar t -&gt; Scalar t) -&gt; t s -&gt; t s
    tmap f x = tzipN (\case I x' :* &#216;V -&gt; f x') (x :* &#216;V)

    tzip
        :: SingI s
        =&gt; (Scalar t -&gt; Scalar t -&gt; Scalar t)
        -&gt; t s
        -&gt; t s
        -&gt; t s
    tzip f x y = tzipN (\case I x' :* I y' :* &#216;V -&gt; f x' y') (x :* y :* &#216;V)

    tzipN
        :: SingI s
        =&gt; (Vec n (Scalar t) -&gt; Scalar t)
        -&gt; VecT n t s
        -&gt; t s
    tzipN f xs = gen sing $ \i -&gt;
        f $ vmap (I . tindex i) xs

    tsize
        :: SingI s
        =&gt; t s
        -&gt; Int

    tindex
        :: SingI s
        =&gt; Prod Finite s
        -&gt; t s
        -&gt; Scalar t

    tconv
        :: Sing n
        -&gt; ProdMap Conv m s
        -&gt; t (m &gt;: n)       -- ^ mask
        -&gt; t s              -- ^ tensor
        -&gt; t (s &gt;: n)

    tslice
        :: ProdMap Slice n m
        -&gt; t n
        -&gt; t m

    treshape
        :: (SingI s1, Product s1 ~ Product s2)
        =&gt; Sing s2
        -&gt; t s1
        -&gt; t s2
    treshape s = tload s . textract

    tload
        :: Sing s
        -&gt; V.Vector (Product s) (Scalar t)
        -&gt; t s
    tload s = fromJust . fromList' s . toList

    textract
        :: SingI s
        =&gt; t s
        -&gt; V.Vector (Product s) (Scalar t)
    {-# MINIMAL genA, tsum, tsize, tindex, tconv, textract, tslice #-}

type family Product (ns :: [Nat]) :: Nat where
    Product '[]       = 1
    Product (n ': ns) = n TL.* (Product ns)

sProduct :: Sing as -&gt; Sing (Product as)
sProduct = \case
    SNil -&gt; SNat
    s `SCons` ss -&gt; s %:* sProduct ss

data DoubleProd :: (k -&gt; Type) -&gt; [k] -&gt; [k] -&gt; Type where
    DPZ :: DoubleProd f '[] '[]
    DPS :: f a -&gt; f b -&gt; DoubleProd f as bs -&gt; DoubleProd f (a ': as) (b ': bs)

instance Known (DoubleProd f '[]) '[] where
    known = DPZ

instance (Known (DoubleProd f as) bs, Known f a, Known f b) =&gt; Known (DoubleProd f (a ': as)) (b ': bs) where
    known = DPS known known known

fromScalar :: Tensor t =&gt; Scalar t -&gt; t '[]
fromScalar x = gen SNil (\_ -&gt; x)

toScalar :: Tensor t =&gt; t '[] -&gt; Scalar t
toScalar = tindex &#216;

fromList'
    :: Tensor t
    =&gt; Sing s
    -&gt; [Scalar t]
    -&gt; Maybe (t s)
fromList' s = evalStateT . genA s $ \_ -&gt; StateT uncons

fromList
    :: Tensor t
    =&gt; Sing s
    -&gt; [Scalar t]
    -&gt; Maybe (t s)
fromList s = case sProduct s of
    SNat -&gt; fmap (tload s) . V.fromList

tlist
    :: (Tensor t, SingI s)
    =&gt; t s
    -&gt; [Scalar t]
tlist = toList . textract

tmapOp
    :: (Tensor t, SingI s)
    =&gt; (forall q. AD q (Forward (Scalar t)) -&gt; AD q (Forward (Scalar t)))
    -&gt; Op '[t s] '[t s]
tmapOp f = op1' $ \x -&gt;
    let y  = tmap (fst . diff' f) x
        dy = tmap (diff f) x
    in  (only_ y, maybe dy (tzip (*) dy) . head')

tzipOp
    :: forall t s. (Tensor t, SingI s)
    =&gt; (forall q. Reifies q Tape =&gt; Reverse q (Scalar t) -&gt; Reverse q (Scalar t) -&gt; Reverse q (Scalar t))
    -&gt; Op '[t s, t s] '[t s]
tzipOp f = op2' $ \x y -&gt;
    let f' :: forall q. Reifies q Tape =&gt; Vec N2 (Reverse q (Scalar t)) -&gt; Reverse q (Scalar t)
        f' (I x' :* I y' :* &#216;V) = f x' y'
        z = tzip (\x' y' -&gt; fst $ grad' f' (x' :+ y' :+ &#216;V)) x y
        g = \case
          Nothing :&lt; &#216; -&gt;
            let dx = tzip (\x' y' -&gt; case grad f' (x' :+ y' :+ &#216;V) of
                                       I dx' :* _ -&gt; dx'
                          ) x y
                dy = tzip (\x' y' -&gt; case grad f' (x' :+ y' :+ &#216;V) of
                                       _ :* I dy' :* _ -&gt; dy'
                          ) x y
            in  (dx, dy)
          Just dz :&lt; &#216; -&gt;
            let dx = tzipN (\(I x' :* I y' :* I d :* &#216;V) -&gt;
                                case grad f' (x' :+ y' :+ &#216;V) of
                                  I dx' :* _ :* &#216;V -&gt; dx' * d
                           ) (x :* y :* dz :* &#216;V)
                dy = tzipN (\(I x' :* I y' :* I d :* &#216;V) -&gt;
                                case grad f' (x' :+ y' :+ &#216;V) of
                                  _ :* I dy' :* &#216;V -&gt; d * dy'
                           ) (x :* y :* dz :* &#216;V)
            in  (dx, dy)
    in  (only_ z, g)

tzipNOp
    :: forall t s n. (Tensor t, SingI s, Known TCN.Nat n)
    =&gt; (forall q. Reifies q Tape =&gt; Vec n (Reverse q (Scalar t)) -&gt; Reverse q (Scalar t))
    -&gt; Op (Replicate n (t s)) '[t s]
tzipNOp f = Op $ \xs -&gt;
    let n :: TCN.Nat n
        n = known
        xs' = vmap getI . prodToVec' n $ xs
        y   = tzipN (fst . grad' f) xs'
        dy  = vgen n $ \i -&gt; I $ tzipN (index' i . grad f) xs'
    in  (only_ y, vecToProd . maybe dy (\g -&gt; tzip (*) g &lt;$&gt; dy) . head')

tkonstOp :: forall t s. Tensor t =&gt; Sing s -&gt; Op '[Scalar t] '[t s]
tkonstOp s = withSingI s $ op1' $ \x -&gt;
    let res = tkonst s x
    in  (only_ res, maybe (fromIntegral (tsize res)) tsum . head')

tsumOp
    :: forall t s. (Tensor t, SingI s)
    =&gt; Op '[ t s ] '[ Scalar t ]
tsumOp = op1' $ \x -&gt;
    ( only_ (tsum x)
    , \case Nothing :&lt; &#216; -&gt; tkonst sing 1
            Just g  :&lt; &#216; -&gt; tkonst sing g
    )

scaleOp
    :: forall t s. (Tensor t, SingI s, Num (t s))
    =&gt; Op '[ Scalar t, t s ] '[ t s ]
scaleOp = op2' $ \&#945; x -&gt;
    ( only_ (tmap (&#945; *) x)
    , \case Nothing :&lt; &#216; -&gt; (tsum x      , tkonst sing &#945;    )
            Just g  :&lt; &#216; -&gt; (tsum (x * g), tkonst sing &#945; * g)
    )

oneHot :: (Tensor t, SingI s) =&gt; Prod Finite s -&gt; t s
oneHot i = gen sing $ \j -&gt; if i `eq1` j then 1 else 0

convert'
    :: (Tensor t, Tensor t', SingI ns)
    =&gt; (Scalar t -&gt; Scalar t')
    -&gt; t ns
    -&gt; t' ns
convert' f = tload sing . fmap f . textract

convert
    :: (Tensor t, Tensor t', SingI ns, Scalar t ~ Scalar t')
    =&gt; t ns
    -&gt; t' ns
convert = convert' id

</span></pre></body></html>