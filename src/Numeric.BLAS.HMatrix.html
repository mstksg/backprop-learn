<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes        #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DeriveGeneric              #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts           #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE GADTs                      #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE InstanceSigs               #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase                 #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables        #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving         #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications           #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies               #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilyDependencies     #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE TypeInType                 #-}</span><span>
</span><a name="line-14"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators              #-}</span><span>
</span><a name="line-15"></a><span class="hs-pragma">{-# LANGUAGE UndecidableInstances       #-}</span><span>
</span><a name="line-16"></a><span class="hs-pragma">{-# LANGUAGE ViewPatterns               #-}</span><span>
</span><a name="line-17"></a><span>
</span><a name="line-18"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">BLAS</span><span class="hs-operator">.</span><span class="hs-identifier">HMatrix</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-19"></a><span>    </span><a href="Numeric.BLAS.HMatrix.html#HM"><span class="hs-identifier hs-type">HM</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-20"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.BLAS.HMatrix.html#HM%27"><span class="hs-identifier hs-type">HM'</span></a><span>
</span><a name="line-21"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.BLAS.HMatrix.html#flatten"><span class="hs-identifier hs-var">flatten</span></a><span>
</span><a name="line-22"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Numeric.BLAS.HMatrix.html#unflatten"><span class="hs-identifier hs-var">unflatten</span></a><span>
</span><a name="line-23"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-24"></a><span>
</span><a name="line-25"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Applicative</span><span>
</span><a name="line-26"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">DeepSeq</span><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">Trans</span><span class="hs-operator">.</span><span class="hs-identifier">State</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Finite</span><span class="hs-operator">.</span><span class="hs-identifier">Internal</span><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Foldable</span><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Function</span><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Kind</span><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">MonoTraversable</span><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">Prelude</span><span>
</span><a name="line-37"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Product</span><span>
</span><a name="line-39"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span>                 </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-40"></a><span class="hs-keyword">import</span><span>           </span><a href="Numeric.BLAS.html"><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">BLAS</span></a><span> </span><span class="hs-keyword">hiding</span><span>          </span><span class="hs-special">(</span><a href="Numeric.BLAS.html#outer"><span class="hs-identifier hs-var">outer</span></a><span class="hs-special">)</span><span>
</span><a name="line-41"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">LinearAlgebra</span><span class="hs-operator">.</span><span class="hs-identifier">Static</span><span>
</span><a name="line-42"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Type</span><span class="hs-operator">.</span><span class="hs-identifier">Family</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span> </span><span class="hs-keyword">hiding</span><span>      </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Reverse</span><span class="hs-special">)</span><span>
</span><a name="line-43"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>                  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">UV</span><span>
</span><a name="line-44"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Generic</span><span class="hs-operator">.</span><span class="hs-identifier">Sized</span><span>    </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">VG</span><span>
</span><a name="line-45"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Sized</span><span>            </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">V</span><span>
</span><a name="line-46"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Storable</span><span>         </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">UVS</span><span>
</span><a name="line-47"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Storable</span><span class="hs-operator">.</span><span class="hs-identifier">Sized</span><span>   </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">VS</span><span>
</span><a name="line-48"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">LinearAlgebra</span><span>        </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">LA</span><span>
</span><a name="line-49"></a><span>
</span><a name="line-50"></a><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><a name="HM%27"><a href="Numeric.BLAS.HMatrix.html#HM%27"><span class="hs-identifier">HM'</span></a></a><span> </span><span class="hs-special">(</span><a name="local-6989586621679593183"><a href="#local-6989586621679593183"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Nat</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><a name="local-6989586621679593184"><a href="#local-6989586621679593184"><span class="hs-identifier">h</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Type</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">h</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">s</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-51"></a><span>    </span><span class="hs-identifier">HM'</span><span> </span><span class="hs-char">'[]            = Double
    HM' '[n]           = R n
    HM' '[m,n]         = L m n
    HM' (n ': m ': ms) = V.Vector n (HM' (m ': ms))

newtype HM :: [Nat] -&gt; Type where
    HM  :: { getHM :: HM' b }
        -&gt; HM b
  deriving (Generic)

type instance Element (HM s) = Double

instance BLAS HM where

    transp (HM x) = HM (tr x)

    scal &#945; (HM x)        = HM (konst &#945; * x)
    axpy &#945; (HM x) (HM y) = HM (konst &#945; * x + y)
    dot    (HM x) (HM y) = x &lt;.&gt; y
    norm2  (HM x)        = norm_2 x
    asum   (HM x)        = norm_1 x
    iamax  (HM x)        = Finite . fromIntegral
                         . LA.maxIndex . extract
                         $ abs x

    gemv &#945; (HM a) (HM x) = \case
        Just (&#946;, HM y) -&gt; HM (konst &#945; * (a #&gt; x) + konst &#946; * y)
        Nothing        -&gt; HM (konst &#945; * (a #&gt; x))
    ger  &#945; (HM x) (HM y) = \case
        Just (HM a) -&gt; HM (konst &#945; * outer x y + a)
        Nothing     -&gt; HM (konst &#945; * outer x y)
    syr  &#945; (HM x) (HM a)          = HM (konst &#945; * outer x x + a)
    gemm &#945; (HM a) (HM b) = \case
        Just (&#946;, HM c) -&gt; HM (konst &#945; * (a &lt;&gt; b) + konst &#946; * c)
        Nothing        -&gt; HM (konst &#945; * (a &lt;&gt; b))
    syrk &#945; (HM a) &#946; (HM c)        = HM (konst &#945; * (a &lt;&gt; tr a) + konst &#946; * c)

instance Tensor HM where
    type Scalar  HM = Double

    gen = \case
      SNil -&gt; \f -&gt; HM $ f &#216;
      n@SNat `SCons` SNil -&gt; \f -&gt; HM . fromJust . create $
        LA.build (fromIntegral (fromSing n))
          (f . only . Finite . round)
      m@SNat `SCons` (n@SNat `SCons` SNil) -&gt; \f -&gt; HM . fromJust . create $
        LA.build (fromIntegral (fromSing m), fromIntegral (fromSing n))
          (\i j -&gt; f (Finite (round i) :&lt; Finite (round j) :&lt; &#216;))
      SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt; \f -&gt; HM $
        V.generate_ $ \i -&gt; getHM $ gen ns (\js -&gt; f (i :&lt; js))

    genA = \case
      SNil -&gt; \f -&gt; HM &lt;$&gt; f &#216;
      n@SNat `SCons` SNil -&gt; \f -&gt;
        fmap (HM . vector) . traverse (f . only . Finite) $
          [0 .. fromSing n - 1]
      m@SNat `SCons` (n@SNat `SCons` SNil) -&gt; \f -&gt;
        fmap (HM . matrix) . traverse f $
          [ Finite i :&lt; Finite j :&lt; &#216; | j &lt;- [0 .. fromSing m - 1]
                                      , i &lt;- [0 .. fromSing n - 1]
          ]
      SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt; \f -&gt; fmap HM $
        sequenceA . V.generate_ $ \i -&gt; getHM &lt;$&gt; genA ns (\js -&gt; f (i :&lt; js))

    tkonst s = HM . hkonst s

    tsum :: forall s. SingI s =&gt; HM s -&gt; Double
    tsum = go sing . getHM
      where
        go :: Sing ns -&gt; HM' ns -&gt; Double
        go = \case
          SNil                                      -&gt; id
          SNat `SCons` SNil                         -&gt; LA.sumElements . extract
          SNat `SCons` (SNat `SCons` SNil)          -&gt; LA.sumElements . extract
          SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt; sum . fmap (go ns)

    tmap :: forall s. SingI s =&gt; (Double -&gt; Double) -&gt; HM s -&gt; HM s
    tmap = omap

    tzip
        :: forall s. SingI s
        =&gt; (Double -&gt; Double -&gt; Double)
        -&gt; HM s -&gt; HM s -&gt; HM s
    tzip f (HM x0) (HM y0) = HM $ hzip f sing x0 y0

    tsize
        :: forall s. SingI s
        =&gt; HM s
        -&gt; Int
    tsize _ = fromIntegral $ product (fromSing (sing @_ @s))

    tindex
        :: forall s. SingI s
        =&gt; Prod Finite s
        -&gt; HM s
        -&gt; Double
    tindex ix0 = go sing ix0 . getHM
      where
        go :: Sing ns -&gt; Prod Finite ns -&gt; HM' ns -&gt; Double
        go = \case
          SNil -&gt; \case
            &#216; -&gt; id
          SNat `SCons` SNil -&gt; \case
            i :&lt; &#216; -&gt; (`LA.atIndex` fromIntegral i) . extract
          SNat `SCons` (SNat `SCons` SNil) -&gt; \case
            i :&lt; j :&lt; &#216; -&gt; (`LA.atIndex` (fromIntegral i, fromIntegral j)) . extract
          SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt; \case
            i :&lt; js -&gt; go ns js . (`V.index` i)

    tslice
        :: forall n m. ()
        =&gt; ProdMap Slice n m
        -&gt; HM n
        -&gt; HM m
    tslice sl0 (HM x0) = HM $ go sl0 x0
      where
        go  :: forall ns ms. ()
            =&gt; ProdMap Slice ns ms
            -&gt; HM' ns
            -&gt; HM' ms
        go = \case
          PMZ -&gt; \x -&gt; x
          PMS (Slice sL sC@SNat sR) PMZ -&gt; \xs -&gt; fromJust . create $
            let l = fromIntegral $ fromSing sL
                c = fromIntegral $ fromSing sC
            in  withKnownNat (sL %:+ sC %:+ sR) $
                  LA.subVector l c (extract xs)
          PMS (Slice sLy sCy@SNat sRy) (PMS (Slice sLx sCx@SNat sRx) PMZ) -&gt;
              \xs -&gt; fromJust . create $
            let lx = fromIntegral $ fromSing sLx
                ly = fromIntegral $ fromSing sLy
                cx = fromIntegral $ fromSing sCx
                cy = fromIntegral $ fromSing sCy
            in  withKnownNat (sLy %:+ sCy %:+ sRy) $
                withKnownNat (sLx %:+ sCx %:+ sRx) $
                  LA.subMatrix (ly, lx) (cy, cx) (extract xs)
          PMS (Slice sL sC@SNat _) pm@(PMS _ (PMS _ _)) -&gt; \xs -&gt;
            let l = fromIntegral $ fromSing sL
                c = fromIntegral $ fromSing sC
            in  fmap (go pm)
                  . fromJust . V.toSized
                  . UV.take c
                  . UV.drop l
                  . V.fromSized
                  $ xs

    tconv
        :: forall n m s. ()
        =&gt; Sing n
        -&gt; ProdMap Conv m s
        -&gt; HM (m &gt;: n)      -- ^ mask
        -&gt; HM s
        -&gt; HM (s &gt;: n)
    tconv sn@SNat pm0 (HM m0) (HM x0) = HM $ go pm0 m0 x0
      where
        go  :: forall ms ss. ()
            =&gt; ProdMap Conv ms ss
            -&gt; HM' (ms &gt;: n)
            -&gt; HM' ss
            -&gt; HM' (ss &gt;: n)
        go = \case
          PMZ -&gt; \m x -&gt; konst x * m
          PMS (Conv sM sS str off) PMZ -&gt; \m x -&gt;
            undefined

    treshape
        :: (SingI s1, Product s1 ~ Product s2)
        =&gt; Sing s2
        -&gt; HM s1
        -&gt; HM s2
    treshape s = unflatten s . flatten

    tload
        :: Sing s
        -&gt; V.Vector (Product s) Double
        -&gt; HM s
    tload s = unflatten s . VG.convert

    textract
        :: SingI s
        =&gt; HM s
        -&gt; V.Vector (Product s) Double
    textract = VG.convert . flatten

-- hconv
--     :: forall o ms ns. (KnownNat o)
--     =&gt; DoubleProd Sing ms ns
--     -&gt; HM' (o ': ms)
--     -&gt; HM' ns
--     -&gt; HM' (o ': ns)
-- hconv = \case
--     DPZ -&gt; \ms x -&gt; konst x * ms
--     DPS SNat sn@SNat DPZ -&gt; \m x -&gt; fromJust . create $
--       let c = LA.conv2 (extract m) (LA.asRow (extract x))
--           o = fromInteger (natVal (Proxy @o))
--           left = o `div` 2
--       in  LA.subMatrix (0,left) (o, fromInteger (fromSing sn)) c
--     DPS smx@SNat snx@SNat (DPS smy@SNat sny@SNat DPZ) -&gt; \m x -&gt;
--       -- todo: vectorize with im2colV
--       flip fmap m $ \msk -&gt; fromJust . create $
--         let c = LA.conv2 (extract msk) (extract x)
--             left = fromInteger (fromSing smx) `div` 2
--             top  = fromInteger (fromSing smy) `div` 2
--         in  LA.subMatrix (left, top) (fromInteger (fromSing snx), fromInteger (fromSing sny)) c
--     dp0@(DPS (SNat :: Sing m0) (SNat :: Sing n0) (DPS _ _ (DPS _ _ _) :: DoubleProd Sing ms0 ns0)) -&gt;
--               \(ms :: V.Vector o (V.Vector m0 (HM' ms0))) (xs :: V.Vector n0 (HM' ns0)) -&gt;
--       flip fmap ms $ \(msk :: V.Vector m0 (HM' ms0)) -&gt; hconv1 dp0 msk xs

-- hconv1
--     :: forall m s. ()
--     =&gt; DoubleProd Sing m s
--     -&gt; HM' m
--     -&gt; HM' s
--     -&gt; HM' s
-- hconv1 = \case
--     DPZ -&gt; (*)
--     DPS sm@SNat sn@SNat DPZ -&gt; \m x -&gt; fromJust . create $
--       let c = LA.conv (extract m) (extract x)
--           left = fromInteger (fromSing sm) `div` 2
--       in  UVS.slice left (fromInteger (fromSing sn)) c
--     DPS smx@SNat snx@SNat (DPS smy@SNat sny@SNat DPZ) -&gt; \m x -&gt; fromJust . create $
--       let c = LA.conv2 (extract m) (extract x)
--           left = fromInteger (fromSing smx) `div` 2
--           top  = fromInteger (fromSing smy) `div` 2
--       in  LA.subMatrix (left, top) (fromInteger (fromSing snx), fromInteger (fromSing sny)) c
--     DPS (SNat :: Sing m0) (SNat :: Sing n0) dps@(DPS _ _ (DPS _ _ _) :: DoubleProd Sing ms0 ns0) -&gt;
--               \(ms :: V.Vector m0 (HM' ms0)) (xs :: V.Vector n0 (HM' ns0)) -&gt;
--       let s   :: Sing ns0
--           s   = prodSing $ secondDP dps
--           cl :: V.Vector n0 (V.Vector m0 (HM' ns0))
--           cl = im2colV (hkonst s 0) xs
--       in  fmap (hsum s . V.zipWith (hconv1 dps) ms) cl

flatten :: SingI s =&gt; HM s -&gt; VS.Vector (Product s) Double
flatten = hflatten sing . getHM

unflatten :: Sing s -&gt; VS.Vector (Product s) Double -&gt; HM s
unflatten s = HM . hunflatten s

hflatten
    :: Sing s
    -&gt; HM' s
    -&gt; VS.Vector (Product s) Double
hflatten = \case
    SNil -&gt; VS.singleton
    SNat `SCons` SNil -&gt; fromJust . VS.toSized . extract
    sn@SNat `SCons` (sm@SNat `SCons` SNil) -&gt; case sn %:* sm of
      SNat -&gt; fromJust . VS.toSized . LA.flatten . extract
    SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt;
      VG.convert . V.concatMap (VG.convert . hflatten ns)

hunflatten
    :: Sing s
    -&gt; VS.Vector (Product s) Double
    -&gt; HM' s
hunflatten = \case
    SNil -&gt; VS.head
    SNat `SCons` SNil -&gt; fromJust . create . VS.fromSized
    SNat `SCons` (sm@SNat `SCons` SNil) -&gt; fromJust . create . LA.reshape (fromInteger (fromSing sm)) . VS.fromSized
    sn@SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt; case sProduct ns of
      sp@SNat -&gt; fromJust
            . V.fromList
            . evalState (replicateM (fromInteger (fromSing sn)) $
                           hunflatten ns . fromJust . VS.toSized &lt;$&gt; state (UVS.splitAt (fromInteger (fromSing sp)))
                        )
            . VS.fromSized

im2col
    :: forall m n o. (KnownNat m, KnownNat n, KnownNat o)
    =&gt; L n m
    -&gt; L n o
im2col = undefined

im2colV
    :: forall m n a. (KnownNat m, KnownNat n)
    =&gt; a
    -&gt; V.Vector n a
    -&gt; V.Vector n (V.Vector m a)
im2colV pad (V.fromSized-&gt;v) = V.generate $ \i -&gt;
      fromJust . V.toSized $ UV.slice i m padded
  where
    padded = UV.concat [UV.replicate left pad, v, UV.replicate right pad]
    m :: Int
    m  = fromIntegral $ natVal (Proxy @m)
    left  = m `div` 2
    right = m - left

hadd :: Sing s -&gt; HM' s -&gt; HM' s -&gt; HM' s
hadd = \case
    SNil                                     -&gt; (+)
    SNat `SCons` SNil                        -&gt; (+)
    SNat `SCons` (SNat `SCons` SNil)         -&gt; (+)
    SNat `SCons` s@(_ `SCons` (_ `SCons` _)) -&gt; liftA2 (hadd s)

hsum :: Foldable f =&gt; Sing s -&gt; f (HM' s) -&gt; HM' s
hsum s = foldl' (hadd s) (hkonst s 0)

hkonst :: Sing s -&gt; Double -&gt; HM' s
hkonst = \case
    SNil                                     -&gt; id
    SNat `SCons` SNil                        -&gt; konst
    SNat `SCons` (SNat `SCons` SNil)         -&gt; konst
    SNat `SCons` s@(_ `SCons` (_ `SCons` _)) -&gt; pure . hkonst s

hzip
    :: (Double -&gt; Double -&gt; Double)
    -&gt; Sing s
    -&gt; HM' s
    -&gt; HM' s
    -&gt; HM' s
hzip f = go
  where
    go :: Sing t -&gt; HM' t -&gt; HM' t -&gt; HM' t
    go = \case
      SNil                             -&gt; f
      SNat `SCons` SNil                -&gt; zipWithVector f
      SNat `SCons` (SNat `SCons` SNil) -&gt;
        (\xs ys -&gt; matrix (zipWith f xs ys))
           `on` (concat . LA.toLists . extract)
      SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt;
         V.zipWith (go ns)

-- firstDP
--     :: DoubleProd f as bs
--     -&gt; Prod f as
-- firstDP = \case
--     DPZ        -&gt; &#216;
--     DPS x _ xs -&gt; x :&lt; firstDP xs

-- secondDP
--     :: DoubleProd f as bs
--     -&gt; Prod f bs
-- secondDP = \case
--     DPZ        -&gt; &#216;
--     DPS _ x xs -&gt; x :&lt; secondDP xs

prodSing
    :: Prod Sing as
    -&gt; Sing as
prodSing = \case
    &#216;       -&gt; SNil
    x :&lt; xs -&gt; x `SCons` prodSing xs

instance SingI s =&gt; MonoFunctor (HM s) where
    omap f = HM . go sing . getHM
      where
        go :: Sing ns -&gt; HM' ns -&gt; HM' ns
        go = \case
          SNil                                      -&gt; f
          SNat `SCons` SNil                         -&gt; dvmap f
          SNat `SCons` (SNat `SCons` SNil)          -&gt; dmmap f
          SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt; fmap (go ns)

helems :: forall s. SingI s =&gt; HM s -&gt; [Double]
helems = go sing . getHM
  where
    go :: Sing ns -&gt; HM' ns -&gt; [Double]
    go = \case
      SNil                                      -&gt; (:[])
      SNat `SCons` SNil                         -&gt; LA.toList . extract
      SNat `SCons` (SNat `SCons` SNil)          -&gt; concat . LA.toLists . extract
      SNat `SCons` ns@(_ `SCons` (_ `SCons` _)) -&gt; foldMap (go ns)

instance SingI s =&gt; MonoFoldable (HM s) where
    ofoldMap f     = foldMap f . helems
    ofoldr f z     = foldr f z . helems
    ofoldl' f z    = foldl' f z . helems
    otoList        = helems
    oall f         = all f . helems
    oany f         = any f . helems
    onull          = (== 0) . olength
    olength _      = fromIntegral (product (fromSing (sing @_ @s)))
    olength64      = fromIntegral . olength
    ocompareLength = ocompareLength . helems
    otraverse_ f   = traverse_ f . helems
    ofor_ x        = for_ (helems x)
    omapM_ f       = traverse_ f . helems
    oforM_ x       = for_ (helems x)
    ofoldlM f x    = foldlM f x . helems
    ofoldMap1Ex f  = ofoldMap1Ex f . helems
    ofoldr1Ex f    = ofoldr1Ex f . helems
    ofoldl1Ex' f   = ofoldl1Ex' f . helems
    headEx         = headEx . helems
    lastEx         = lastEx . helems
    maximumByEx f  = maximumByEx f . helems
    minimumByEx f  = minimumByEx f . helems

deriving instance NFData (HM' s)     =&gt; NFData (HM s)
deriving instance Show (HM' s)       =&gt; Show (HM s)
deriving instance Num (HM' s)        =&gt; Num (HM s)
deriving instance Fractional (HM' s) =&gt; Fractional (HM s)
deriving instance Floating (HM' s)   =&gt; Floating (HM s)

</span></pre></body></html>